\input texinfo   @c -*-texinfo-*-
@input texiplus
@c %**start of header

@c oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
@c                                                                            o
@c                           GPRBUILD DOCUMENTATION                           o
@c                                                                            o
@c                  G P R B U I L D   U S E R ' S   G U I D E                 o
@c                                                                            o
@c                     Copyright (C) 2007, AdaCore                            o
@c                                                                            o
@c oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

@setfilename gprbuild_ug.info
@settitle GPRBUILD User's Guide
@setchapternewpage odd
@syncodeindex fn cp

@titlepage

@title GPRBUILD User's Guide
@c @subtitle Date: $Date: 2006/09/11 04:02:07 $
@author AdaCore

@page
@vskip 0pt plus 1filll

Printed March 2007 @*
Copyright @copyright{} 2007, AdaCore

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.
@end titlepage

@ifnottex
@node Top, Introduction, (dir), (dir)
@top GPRBUILD User's Guide

@noindent
@c GPRBUILD User's Guide@*
@c Document revision level $Revision: 1.0 $@*
@*
@noindent
AdaCore@*

@menu
* Introduction::
* Guided Tour::
* Important Concepts::
* Building with gprbuild::
* Cleaning up with gprclean::
* Configuring with gprconfig::
* Configuration File Reference::
* Index::

@detailmenu
 --- The Detailed Contents ---@*

Introduction

Important Concepts

Guided Tour
* First Steps::
* Subsystems::
* Project Extensions::
* Libraries::
* Scenarios and conditional source files::

Building with gprbuild
* Command Line::
* Switches::
* Initialisation::
* Compilation of one or several sources::
* Compilation Phase::
* Post-Compilation Phase::
* Linking Phase::

Cleaning up with gprclean

Configuring with gprconfig
* Using gprconfig::
* Description of the knowledge base::
* General file format::
* Compiler description::
* Configurations::

Configuration File Reference

Index
@end detailmenu
@end menu
@end ifnottex

@c  ------------------------------------------------------------------------
@node Introduction
@unnumbered Introduction
@c  ------------------------------------------------------------------------

gprbuild is a generic build tool designed for the construction of
big multi-language systems organized into subsystems and libraries.
It is well-suited for compiled languages offering separate compilation units
such as Ada, C, C++ or Fortran.

@noindent
gprbuild manages a three step build process
@itemize @bullet
@item compilation phase:

each compilation unit of each subsystem is examined in turn, checked for
consitency and compiled or recompiled when necessary by the appropriate
compiler.  The recompilation decision is based on dependency information
usually produced by a former compilation.

@item post-compilation phase (or binding):

Compiled units of a given language are passed to a language specific
post-compilation tool if any. This is also during this phase
that objects are grouped into static or dynamic libraries as specified.

@item linking phase:

All units or libraries from all subsystems are passed to a linker tool
specific to the set of toolchains used together.
@end itemize

@noindent
@code{gprbuild} takes as its main input a project file (<file>.gpr)
defining the build characteristics of the system under construction
such as:
@itemize
@item which sources to use,
@item where to find them,
@item where to store the objects produced by the compiler,
@item which options should the compiler be invoked with, etc.
@end itemize

It is generic in the sense that it provides, when possible, equivalent
build capabilities for all supported languages. For this, it uses a
configuration file (<file>.cgpr) which has a syntax and structure very
similar to a project file, but whose goal is to define the characteristics
of the supported languages and toolchains. The configuration file contains
information such as:
@itemize
@item what are the default source naming conventions for each language
@item what is compiler name, location and mandatory options,
@item how to compute inter-unit dependency,
@item how to build static or dynamic libraries,
@item which post-compilation actions are needed,
@item how to link together units from different languages.
@end itemize

On the other hand, @code{gprbuild} is not a replacement for general-purpose
build tools such as @code{make} or @code{ant} which give the user a high
level of control on the build process itself. When building a system
requires complex actions that do not fit well in the three-phase process
described above, @code{gprbuild} is not able to manage all the aspects
of the build process on its own. In such complex situations, it can still
be used sucessfully to address the appropriate part of the build. For
instance it can be called from within a Makefile.

@c  ------------------------------------------------------------------------
@node Important Concepts
@chapter Important Concepts
@c  ------------------------------------------------------------------------

Let's discuss some of the important concepts that are the foundation of the
GNAT Project files and the GPRbuild process.

@itemize @bullet

@item source files and source directories:

A source file is associated to a language through a naming convention.
For instance, @code{foo.c} is typically
the name of a C source file; @code{bar.ads} or @code{bar.1.ada} are 2
common naming conventions for a file containing an Ada spec; etc.
A compilation unit is often composed of a main source file and potentially
several auxillary ones, such as header files in C. The naming conventions
can be defined or modified by the user and are used by
@code{gprbuild} to invoke the appropriate compiler.
Source files are looked for in the source directories associated to the
project with the @code{Source_Dirs} attribute. By default,
all the files in the source directories following the naming conventions
associated with the declared languages are
considered to be part of the project. It is also possible to limit the
list of source files using the @code{Source_Files} or
@code{Source_List_File} attributes.

@item object files and object directory:

An object file is an intermediate file produced by the compiler from a
compilation unit. It is used by the post-compilation phases to produce
final executables or libraries. The object files produced in the context of
a given project are stored in a single directory, the Object_Dir that can
be specified in the project file. A need for storing
objects in different directories corresponds to the need to split the
system into distinct subsystems.

@item project file:

A text file using an Ada-like syntax. It defines build-related
characterists of an application, or a part of it. The characteristics
include the list of sources, the location of those sources, the location
where to store the generated object files, the name of the main program
and the default options for the various tools involved in the build
process. Those characteristics can be conditionalized thanks to scenario
variables and case statements.

@item configuration file:

A text file using the project file syntax. It defines languages and
their characteristics as well as toolchains for those languages and their
characteristics.

@item project attribute:

A specific characteristic is defined by a project attribute clause. Its
value is a string or a sequence of strings. For instance, the Source_Dirs
attribute is a sequence of strings representing the actual names of the
directories containing the sources of the project. The attribute itself can
be parameterized. For instance @code{Compiler'Default_Options ("Ada")}
refers to the default compiler options for the Ada language.

@item project subpackage:

Global characteristics are defined at the top level of the projects.
Specific characteristics affecting a given tool are grouped in a
subpackage named after the type of tools it affects. The most common
subpackages are "Builder", "Compiler", "Binder" and "Linker".

@item project variables:

Two kinds of variables are available with projects: simple variables and
scenario variables. The former can hold any string, or sequence of string
values. They are useful as shortcut for complex expressions. Scenario
variables are a restricted version of the former which can only take their
value from a static enumeration of strings representing the various
supported scenarios. Those scenario variables are used conjointly with
the @code{case} construct to offer limited conditionalization of
project characteristics. Both types of variables are local to the project
defining them and can get initialized with an external value, such as
an environment variable, thanks to the @code{external} directive.

@item subsystem:

A subsystem is a coherent part of the complete system to be built. It
is represented by a set of sources and one object directory. A simple
system is composed of a single subsystem. Complex systems are
usually composed of a graph of interdependant subsystems. A subsystem is
dependant on another subsystem if it cannot be built without any
knowledge of the other one, and in particular if visibility on some of
the sources of this other subsystem is required. A subsystem is usually
represented by one project file. The subsystem dependency relationship
is represented by the @code{with} clause between corresponding project
files.

@item library:

A Library is a specific type of subsystem where the objects are
grouped together using system specific means for the conveniency
of the user. Project files are a system and language independant way of
building both static and dynamic libraries. They also support the concept
of standalone libraries (SAL) which offers two significant properties: the
initialization of the library is either automatic or very simple; a
change in the implementation part of the library implies minimal
post-compilation actions on the complete system and potentially no
action at all for dynamic SALs.

@item Project extension:

A project extension is a project that represents a non-perturbing
modification of the original project. Suppose for instance that a
subsystem is shared by 2 different unrelated systems. If one system
requires a change in the subsystem it may affect the other system
negatively. In order to preserve as much sharing of the subsystem, it is
possible to represent a new version of the subsystem as a delta to the
original version which only contains the new source files, those that have
been changed and the objects that are affected by these changes.
@end itemize

@c  ------------------------------------------------------------------------
@node Guided Tour
@chapter Guided Tour
@c  --------------------------------------------------------------------------

@menu
* First Steps::
* Subsystems::
* Project Extensions::
* Libraries::
* Scenarios and conditional source files::
@end menu

This chapter will guide you, through examples, from the simplest cases of
multi-language builds to some of the most advanced capabilities of
@code{gprbuild}. Note that all the examples used in the text are extracted
from the examples of the gprbuild package which are installed on your
system in <prefix>/share/examples/gprbuild/.

GPRbuild needs one configuration file describing the languages and
toolchains to be used as well as project files describing the
characteristics of the user project. In simple cases, the configuration
file can be created automatically by GPRbuild based on the languages
defined in users projects and the compilers on his path. There are more
involved situations such as cross-compilation,
rich environments with different compilers for the same language, etc.
where it may be needed to control precisely the generation of
the desired configuration of toolsets. A tool, @code{gprconfig}, described in a
latter chapter, offers this capability. In the context of this
guided tour, autoconfiguration is appropriate and thus we will not discuss
here issues related to configuration.

@node First Steps
@section First Steps

Let's assume a simple case of interfacing between Ada and C where the main
program is first in Ada and then in C. For a main program in Ada, we can
use a project of the sort:

@smallexample @c projectfile
project Ada_Main is
   for Languages    use ("Ada", "C");
   for Source_Dirs  use ("ada_src", "util_src");
   for Object_Dir   use  "obj";
   for Exec_Dir     use ".";
   for Source_Files use ("ada_main.adb", "c_lib.ads", "lib.h", "lib.c");
   for Main         use ("ada_main.adb");
end Ada_Main;
@end smallexample

@noindent
This project says that:
@itemize
@item the sources files of this subsystem are written in Ada and C.
@item the list of directories containing the sources is composed of
two directories called @code{ada_src} and @code{util_src}.
@item the directory holding the objects is @code{obj}.
@item the directory holding the executables is @code{.}, that is to say the
directory containing the project file itself.
@item the complete list of source files is @code{ada_main.adb},
@code{c_lib.ads}, @code{lib.h}, @code{lib.c}. They can be found anywhere
in the source directories mentioned above.
@item the main entry point of the system is in the source file
@code{ada_main.adb}.
@end itemize
Those elements are sufficient for @code{gprbuild} to build an executable
program out of the sources. Note that no direct indication on how to build
the various elements are given in the project file which remains a
description of the project properties rather than a set of actions to
be executed. Here is the invocation of
@code{gprbuild} that allows building the multi-language program:
@smallexample
$ gprbuild -Pada_main
gcc -c ada_main.adb -o ada_main.o
gcc -c c_lib.ads -o c_lib.o
gcc -c lib.c -o lib.o
gprbind ada_main
<...>
gcc ada_main.o -o ada_main.exe
@end smallexample

@noindent
One notices the three steps described in the introduction of this document:
the first gcc commands correspond to the compilation phase. The gprbind
command corresponds to the post-compilation phase while the last gcc command
corresponds to the final link. Note that the default output of the
gprbuild execution is kept reasonnably simple and easy to understand for
the user. It means, in particular, that some of the unimportant commands
are not shown and that some parameters are abbreviated. GPRbuild's option
@code{-v} provides a much more verbose output which includes, among other
information, more complete and accurate compilation, post-compilation and
link commands.

Let's now see other project capabilities through a slightly different
project using similar sources and a main program in C:

@smallexample @c projectfile
project C_Main is
   for Languages    use ("Ada", "C");
   for Source_Dirs  use ("c_src", "util_src");
   for Object_Dir   use  "obj1";
   for Main         use ("c_main.c");
   package Compiler is
      C_Switches := ("-pedantic");
      for Default_Switches ("C")   use C_Switches;
      for Default_Switches ("Ada") use ("-gnaty");
      for Switches ("c_main.c")    use C_Switches & ("-g");
   end Compiler;
end C_Main;
@end smallexample

@noindent
This project has many similarities with the previous one. The Languages,
Source_Dirs and Object_Dirs are similar. As expected, its Main attribute
now refers to a C source. The first noticeable difference is the lack of
Source_Files attribute. When not specified explicitly, this attribute has
an implicit value which the complete set of sources of the given Languages to
be found in the Source_Dirs. Many attributes can be let implicit and have a
reasonable default value. For instance, the Source_Dirs and the Object_Dir
default to the current directory (where the project file resides). The
Exec_Dir defaults to the value of the Object_Dir. Etc.

The other notable difference in this new project is the presence of the
package Compiler whose purpose is to group the attributes specific to
the compilation phases. The Default_Switches attribute provides the
list of compilation switches to be used for any source of a given
Language unless the source has its own set of compilation switches
specified by the attribute Switches. Note also the use of a variable
(C_Switches). It can be useful to avoid duplication of information and is
used in this context to ensure that the file c_main.c is always compiled
with the default switches whatever they are, plus @option{-g}. In this specific
situation, the use of a variable could have been replaced by a reference
to the Default_Switches attribute:

@smallexample @c projectfile
   for Switches ("c_main.c") use Compiler'Default_Switches ("C") & ("-g");
@end smallexample

@noindent
Here is the output of the gprbuild command using this project:

@smallexample
$gprbuild -Pc_main
gcc -c -pedantic -g c_main.c -o c_main.o
gcc -c -gnaty ada_lib.adb -o ada_lib.o
gcc -c -gnaty c_lib.ads -o c_lib.o
gcc -c -pedantic lib.c -o lib.o
gprbind c_main
<...>
gcc c_main.o -o c_main.exe
@end smallexample

@noindent
The switches for compiling Ada sources have been taken into account as well
as the default switches for C sources in the compilation of lib.c. One can
also observe that the specific switches for c_main.c have been taken into
account. When comparing this gprbuild output with the previous one, one can
notice that there are common sources between the two projects, namely
c_lib.ads and lib.c. Those sources were compiled twice, once for each
projects it is part of. This is not surprising since the two projects
are independant and have different @code{Object_Dir}s eventhough they share
some sources. Would it be possible to share more than the sources and in
particular avoid unnecessary recompilations when compilation units are
used in several different projects? Splitting the current system into
subsystems is a way forward in answering this question.

@node Subsystems
@section Subsystems
@c describe a bigger project with several source dirs and object dirs
@c describe limited with & extended projects & source duplication.

Let's group the common compilation units in a separate subsystem with
its own project file to which we attribute a separate Object_Dir:

@smallexample @c projectfile
project Common_Subsystem is
   for Source_Dirs  use ("util_src");
   for Object_Dir   use  "obj_util";
end Common_Subsystem;
@end smallexample

@noindent
So now by default, all the sources in directory @code{util_src} belong to
project Common_Subsystem and when compiled, their objects go in @code{obj_dir}.
Other projects, whose sources depend on sources in @code{util_src} can create
a dependency relationship using a project @code{with} clause:

@smallexample @c projectfile
with "Common_Subsystem";
project Ada_Main is
   for Languages    use ("Ada");
   for Source_Dirs  use ("ada_src");
   ...
end Ada_Main;
@end smallexample

@noindent
The @code{Ada_Main.Source_Dirs} does not include @code{util_src} anymore. The
main program in @code{ada_src} still needs sources from @code{util_src} to be
compiled.
It also needs those units built. Now they will be compiled using the build
properties defined in Common_Subsystem instead of those of Ada_Main. The
project's @code{with} clause has several effects: it provides visibility of
sources during the compilation process as if the units from Ada_Main were
compiled with an implcit @code{-Iutil_src}; it also guarantees that the
necessary units from Common_Subsystems are available for Ada_Main linking
phase.

It is also possible to use the @code{with} relationship to define a project file
that allows sharing common attributes or packages. For instance, one can
 define a project whose only purpose is to centralize the default
compilation options for various languages:

@smallexample @c projectfile
project Attribute_Sharing is
   for Source_Files use ();
   package Compiler is
      for Default_Switches ("C")   use ("-pedantic");
      for Default_Switches ("Ada") use ("-gnaty");
   end Compiler;
end Attribute_Sharing;
@end smallexample

@noindent
This package does not correspond to a subsystem with
proper source files and this is conveyed by the definition of @code{Source_Files}
which is explicitly set to the empty list. It informs the build manager
that no compilation is to take place directly from this project. Defining
an empty list of sources is essential for such utility packages because
otherwise, the default rules apply and all sources in the current directory
will be associated with this project. Now other projects can share this
project's attributes and packages. For instance, Ada_Main can share all the
Compiler's attribute at once using a renaming declaration:

@smallexample @c projectfile
with "Attribute_Sharing";
...
project Ada_Main is
...
   package Compiler renames Attribute_Sharing.Compiler;
end Ada_Main;
@end smallexample

@noindent
or if other aspects of the Compiler package need to be defined locally,
as adding @code{-g} for the c_main.c source only, sharing can be done at the
attribute level directly as in this new version of C_Main.Compiler:
@smallexample @c projectfile
   package Compiler is
      for Default_Switches ("C") use
        Attribute_Sharing.Compiler'Default_Switches ("C");
      for Switches ("c_main.c")  use
        Compiler'Default_Switches ("C") & ("-g");
   end Compiler;
@end smallexample
If one wants to change the compilation options of all C files used for
building both @code{C_Main} and @code{Ada_Main}, it is sufficient to edit a
single project file.

@node Project Extensions
@section Project Extensions

We have seen how to share both compilation units and project properties
among different systems. Sharing is an essential aspect of big system
programming since it helps getting organized, reduces compilation time and
reduces the maintenance burden. Unfortunately, it gets sometimes in the way.
In the above example, @code{Ada_Main} and @code{C_Main both} depend on
@code{Common_Subsystems} because they have precisely the same needs but the
requirements of the two systems can diverge over time in which case
sharing becomes a problem rather than a solution. For instance let us
suppose that C_Main is now under maintenance and should not be changed
carelessly while Ada_Main is still under active development which requires
changes in the sources of the common subsystem. How can we satisfy
Ada_Main's needs without taking any risk of perturbing C_Main? One
possibility is to duplicate the common subsystem completely so that one
version can evolve while the other one can remain frozen. That will force
duplication and recompilation of the whole project. Extensions provide a
more flexible mechansim making it possible to provide a new version of
a subsystem without having to duplicate the sources which do not change.
A project extension inherits all the sources and objects from the project it
extends and allow to redefine some of the sources which hide the original
versions. One can also add new sources or remove existing ones.
Here is an example of extension of project common_subsystem:

@smallexample @c projectfile
project New_Common_Subsystem extends "../subsystems/common_subsystem.gpr" is
   for Source_Dirs  use ("new_util_src");
   for Object_Dir   use  "new_obj_util";
end New_Common_Subsystem;
@end smallexample

The project sources are to be found in @code{Common_Subsystem.Source_Dirs}
and @code{New_Common_Subsystem.Source_Dirs}, the latter hiding the former
when the same source filenames are found in both. New sources can be
added to the project extension by simply placing them in its
Source_Dirs. Original Sources can be removed thanks to the Attribute
@code{Locally_Removed_Files}.
When building a project extension, all units depending on new versions of
sources are rebuilt in the extension's @code{Object_Dir}. Other objects
remain in their original location and will be used by the builder whenever
necessary.

We have seen how to define a project extension but how can this extension
be used in the context of a big program composed of many subsystems?
Extending one subsystem may affect implicity many other subsystems
depending on it eventhough there are no source change in those
dependant projects. In order to avoid the necessity for generating a
project extension for each of the affected subsystems, one can use the
notion of "extending all" which basically means "extend all the projects
necessary so that this specific project extension can be used instead of
its original version. Here is an example of an extending-all project:

@smallexample @c projectfile
with "new_common_subsystem.gpr";
project New_Ada_Main extends all "../subsystems/ada_main.gpr" is
   for Source_Dirs  use ("new_ada_src");
   for Object_Dir   use  "new_obj";
   for Exec_Dir     use ".";
end New_Ada_Main;
@end smallexample

@node Libraries
@section Libraries
@c augment the previous example with putting one of the
@c subsystem in a library
@c show how to deal with externa libraries

@node Scenarios and conditional source files
@section Scenarios and conditional source files




@c  ------------------------------------------------------------------------
@node Building with gprbuild
@chapter Building with gprbuild
@c  ------------------------------------------------------------------------

@menu
* Command Line::
* Switches::
* Initialisation::
* Compilation of one or several sources::
* Compilation Phase::
* Post-Compilation Phase::
* Linking Phase::
@end menu

@node Command Line
@section Command Line

@noindent

Three elements can optionally be specified on gprbuild's command line:
the main project file, the switches for gprbuild itself or for the tools it
drives and finally, the main source files:
@smallexample
gprbuild [<proj>.gpr] [switches] [names]
  @{[-cargs opts] [- cargs:lang opts] [-largs opts][-gargs opts]@}
@end smallexample

If the main project file is not specified on the command line, either
directly or using the @option{-P} switch, gprbuild uses the project file
"default.gpr" if there is one in the current working directory. Otherwise,
if there is only one project file in the current working directory, gprbuild
uses this project file.

Main source files represent the sources to be used as the main programs. If
they are not specified on the command line, gprbuild uses
the source files specified with the Main attribute in the project file. If
none exists, then no executable will be built.

When main source files are
specified along with switch @option{-c}, then only recompilation will
be considered only for those source files. In all other cases, gprbuild
compiles or recompiles all sources in the project tree
that are not up to date and build or rebuild libraries that are not up to
date.

The different command line separators are:

@itemize @bullet

@item @option{-cargs}

The arguments that follow up to the next command line separators are
options for all the compilers.
Example: "@option{-cargs -g}"

@item @option{-cargs:}<language name>

The arguments that follow up to the next command line separators are
options for the compiler of the specific language.

Examples:
"@option{-cargs:Ada -gnatf}" or
"@option{-cargs:C -E}"

@item @option{-bargs}

The arguments that follow up to the next command line separators are
options for all binder drivers.

@item @option{-bargs:}<language name>

The arguments that follow up to the next command line separators are
options for the binder driver of the specific language.

Examples:
"@option{-bargs:Ada binder_prefix=ppc-elf}" or
"@option{-bargs:C++ c_compiler_name=ccppc}"

@item @option{-largs}

The arguments that follow up to the next command line separators are
options for the linker.

@item @option{-gargs}

The arguments that follow up to the next command line separators are
options for gprbuild itself. Usually, @option{-gargs} is specified after one or
several other command line separators.

@end itemize

@node Switches
@section Switches

@noindent

The switches that are interpreted directly by gprbuild are:

@itemize @bullet

@item @option{--version}

Display information about gprbuild: version, origin and legal status, then
exit successfully, ignoring other options.

@item @option{--help}

Display gprbuild usage, then exit successfully, ignoring other options.

@item @option{--display-paths}

Display the configuration project file search path and the user project file
search path, then exit successfully, ignoring other options.

@item @option{--config=<config project file name>}

This specifies the configuration project file name. By default, the
configuration project file name is "default.cgpr". Option @option{--config=}
cannot be specified several times.

@item @option{-aP dir} (Add directory dir to project search path)

Specify to gprbuild to add directory "dir" to the user project file search
path, before the default directory.

@item @option{-b} (Bind only)

Specify to gprbuild that the post-compilation (or binding) phase is to be
performed, but not the other phases, if they are not specified by appropriate
switches.

@item @option{-c} (Compile only)

Specify to gprbuild that the compilation phase is to be performed, but not
the other phases, if they are not specified by appropriate switches.

@item @option{-d} (Display progress)

Display progress for each source, up to date or not, as a single
line "completed x out of y (zz%)...". If the file needs to be compiled
this is displayed after the invocation of the compiler. These lines are
displayed even in quiet output (switch @option{-q}).

@item @option{-eL} (Follow symbolic links when processing project files)

By default, symbolic links are not taken into account to compute directories
when processing project files. Switch @option{-eL} changes this default
behavior.

@item @option{-f} (Force recompilations)

Force the complete processing of all phases (or of those explicitly specified)
even when up to date.

@item @option{-F} (Full project path name in brief error messages)

By default, in non verbose mode, when an error occurs while processing
a project file, only the simple name of the project file is displayed in the
error message. When switch @option{-F} is used, the full path of the project
file is used. This switch has no effect when switch @option{-v} is used.

@item @option{-j<num>} (use num simultaneous compilation jobs)

By default, gprbuild invokes one compiler at a time. With switch @option{-j},
it is possible to instruct gprbuild to spawn several simultaneous compilation
jobs if needed. For example, @option{-j2} for two simultaneous compilation
jobs or @option{-j4} for four.

@item @option{-k} (Keep going after compilation errors)

By default, gprbuild stops spawning new compilation jobs at the first
compilation failure. Using switch @option{-k}, it is possible to attempt to
compile/recompile all the sources that are not up to date, even when some
compilations failed. The post-compilation phase and the linking phase are never
attempted if there are compilation failures, even when switch @option{-k} is
used.

@item @option{-l} (Link only)

Specify to gprbuild that the linking phase is to be performed, but not
the other phases, if they are not specified by appropriate switches.

@item @option{-o name} (Choose an alternate executable name)

Specify the file name of a single executable. Switch -o cannot be used with
several mains on the command line or with no main on the command line and
several mains in attribute Main of the main project.

@item @option{-p} (Create missing object, library and exec directories)

By default, gprbuild check that the object, library and exec directories
specified in project files exist. Switch @option{-p} instructs gprbuild to
attempt to create missing directories.

@item @option{-P proj} (use Project file proj)

Specify the path name of the main project file. The space between @option{-P}
and the project file name is optional. Specifying a project file name (with
suffix ".gpr") may be used in place of option @option{-P}. Only one user
project file can be specified.

@item @option{-q} (Quiet output)

Do not display anything except errors and progress (switch @option{-d}).
Cancel any previous switch @option{-v}.

@item @option{-s} (recompile if compilation switches have changed)

By default, gprbuild will not recompile a source if all dependencies are
satisfied. Switch @option{-s} instructs gprbuild to recompile sources when a
different set of compilation switches has been used in the previous
compilation, even if all dependencies are satisfied. Each time gprbuild
invokes a compiler, it writes a text file that lists the switches used in the
invocation of the compiler, so that it can retrieve these switches if
@option{-s} is used later.

@item @option{-v} (Verbose output)

Display full paths, all options used in spawned processes and reasons why
these processes are spawned. Cancel any previous switch @option{-q}.

@item @option{-vPx} (Specify verbosity when parsing Project Files)

By default, gprbuild does not display anything when processing project files,
except when there are errors. This default behavior is obtained with switch
@option{-vP0}. @option{-vP1} gives more information and @option{-vP2} displays
a lot of mostly useless information.

@item @option{-we} (Treat all warnings as errors)

When @option{-we} is used, any warning during the processing of the project
files becomes an error and gprbuild does not attempt any of the phases.

@item @option{-wn} (Treat warnings as warnings)

Switch @option{-wn} may be used to restore the default after @option{-we} or
@option{-ws}.

@item @option{-ws} (Suppress all warnings)

Do not consider any warning while processing the project files.

@item @option{-Xnm=val} (Specify an external reference for Project Files)

Specify an external reference that may be queried inside the project files
using built-in function "external". For example, with @option{-XBUILD=DEBUG},
external("BUILD") inside a project file will have the value "DEBUG".

@end itemize

@node Initialisation
@section Initialisation

@noindent

Before performing one or several of its three phases, gprbuild has to read the
command line, get its configuration and process the project files.

If gprbuild is invoked with an invalid switch or without any project file on
the command line, it will fail immediately.

Examples:

@smallexample
$ gprbuild -P
gprbuild: project file name missing after -P

$ gprbuild -P c_main.gpr -WW
gprbuild: illegal option "-WW"
@end smallexample

gprbuild looks for the configuration project file first in the current
working directory, then in the default configuration project directory.
If the gprbuild executable is located in a subdirectory "<prefix>/bin", then
the default configuration project directory is "<prefix>/share/gpr", otherwise
there is no default configuration project directory.

When it has found its configuration project path, gprbuild needs to get its
configuration. By default, the file name of the main configuration project
is "default.cgpr". This default may be modifed using the switch
@option{--config=...}

Example:

@smallexample
$ gprbuild --config=my_standard.cgpr -P my_project.gpr
@end smallexample

If gprbuild cannot find the main configuration project on the configuration
project path, then it will fail with an error message such as:

@smallexample
$ gprbuild --config=my_standard.cgpr -P my_project.gpr
gprbuild: could not locate main configuration project my_standard.cgpr
@end smallexample

Once it has found the main configuration project, gprbuild will process its
configuration. If the configuration project is not correct
(see @ref{Configuration File Reference}), then gprbuild will fail with
the appropriate error message:

@smallexample
$ gprbuild --config=my_standard.cgpr -P c_main.gpr
my_standard.gpr:3:11: undefined attribute "compiler_drive"
gprbuild: processing of configuration project ".../my_standard.cgpr" failed
@end smallexample

When gprbuild has successfully processed its configuration, then it will
process the user project file or files. If these user project files are
incorrect then gprbuild will fail with the appropriate error messages:

@smallexample
$ gprbuild -P my_project.gpr
ada_main.gpr:3:26: "src" is not a valid directory
gprbuild: "my_project.gpr" processing failed
@end smallexample

Once the user project files have been processed successfully, then gprbuild
will start to do some work.

@node Compilation of one or several sources
@section Compilation of one or several sources

If gprbuild is invoked with -c and there are one or several source file names
specified on the command line, gprbuild will compile or recompile these
sources, if they are not up to date or if -f is also specified.
Then gprbuild will stop its execution, even if -b or -l are specified.

The options/switches used to compile these sources are described in section
@ref{Compilation Phase}.

@node Compilation Phase
@section Compilation Phase

When switch @option{-c} is used or when switches @option{-b} or @option{-l}
are not used, gprbuild will first compile or recompile all the sources that
are not up to date in all the projects in the project tree.

gprbuild will first consider each source and decide if it needs to be
(re)compiled.

A source needs to be compiled in the following cases:

@itemize @bullet

@item Switch @option{-f} (force recompilations) is used

@item The object file does not exist

@item The object file is more recent than the source

@item The dependency file does not exist

@item The dependency file is more recent than the source

@item The switch file does not exist

@item The switch file is more recent than the source

@item The dependency file cannot be read

@item The dependency file is empty

@item The dependency file has a wrong format

@item A source listed in the dependency file does not exist

@item A source listed in the dependency has an incompatible time stamp

@item A source listed in the dependency file has been replaced

@item Switch @option{-s} is used and the source has been compiled with different
      switches or with the same switches in a different order

@end itemize

When a source is successfully compiled, the following files are normally
created in the object directory of the project of the source:

@itemize @bullet

@item An object file

@item A dependency file, except when the dependency kind for the language
      is "none"

@item A switch file

@end itemize

The compiler for the language of the source is invoked with the following
switches/options:

@itemize @bullet

@item The minimum default compilation switches for the language

@item The global compilation switches coming from package Builder of the
      main project

@item The compilation switches coming from package Compiler of the project of
      the source

@item The compilation switches specified on the command line for all compilers,
      after "@option{-cargs}"

@item The compilation switches for the language of the source, specified
      after "@option{-cargs:<language>}"

@item Various other options such as a switch to create the dependency file
      while compiling, a switch to specify a configuration file, a switch
      to specify a mapping file or switches to indicate where to look for
      other source or header files that are needed to compile the source.

@end itemize

If compilation is needed, then all the options/switches, except those
described as "Various other options" are written to the switch file.
The switch file is a text file. Its file name is obtained by replacing
the suffix of the source with ".cswi". For example, the switch file
for source "main.adb" is "main.cswi" and for "toto.c" it is "toto.cswi".

If the compilation is successful, then if the creation of the dependency
file is not done during compilation but after (see configuration attribute
Compute_Dependency), then the process to create the dependency file is
invoked.

If gprbuild is invoked with a switch @option{-j} specifying more than one
compilation process, then several compilation processes for several sources of
possibly different languages are spawned concurrently.

@node Post-Compilation Phase
@section Post-Compilation Phase

@node Linking Phase
@section Linking Phase


@c  ------------------------------------------------------------------------
@node Cleaning up with gprclean
@chapter Cleaning up with gprclean
@c  ------------------------------------------------------------------------

@menu
* Switches for gprclean::
@end menu

gprclean is a tool associated with gprbuild to remove the files created by
gprbuild. At the minimum, gprclean must be invoked with a main project file
with a command such as "gprclean proj.gpr" or "gprclean -P proj.gpr".

Examples of invocation of gprclean:

@smallexample
   gprclean -r prj1.gpr
   gprclean -c -P prj2.gpr
@end smallexample

@node Switches for gprclean
@section Switches for gprclean

The switches for gprclean are:

@itemize @bullet

@item  @option{--config=<main config project file name>} : Specify the
       configuration project file name

@item  @option{-c} : Only delete compiler generated files. Do not delete
       executables and libraries.

@item  @option{-f} : Force deletions of unwritable files

@item  @option{-F} : Display full project path name in brief error messages

@item  @option{-h} : Display this message

@item  @option{-n} : Do not delete files, only list files to delete

@item  @option{-P<proj>} : Use Project File <proj>.

@item  @option{-q} : Be quiet/terse. There is no output, except to report
        problems.

@item  @option{-r} : (recursive) Clean all projects referenced by the main
       project directly or indirectly. Without this switch, gprclean only
       cleans the main project.

@item  @option{-v}  : Verbose mode

@item  @option{-vPx} : Specify verbosity when parsing Project Files.
       x = 0 (default), 1 or 2.

@item  @option{-Xnm=val} : Specify an external reference for Project Files.

@end itemize

@c  ------------------------------------------------------------------------
@node Configuring with gprconfig
@chapter Configuring with gprconfig
@c ----------------------------------------------------------------------

@menu
* Using gprconfig::
* Description of the knowledge base::
* General file format::
* Compiler description::
* Configurations::
@end menu

@c ----------------------------------------------------------------------
@node Using gprconfig
@section Using gprconfig
@c ---------------------------------------------------------------------

@noindent
When you launch gprconfig, it will first search for all compilers it
can find on your @code{PATH}. It is recommended, although not
mandatory, that you put the compilers that you expect to use for your
application in your @code{PATH} before you launch @code{gprconfig},
since that simplifies the setup.

@code{gprconfig} will then display a list of all the native compilers
it has found, along with the language they can compile, the runtime
they use (when applicable),@dots{}. It will then wait until you select
one of the compilers.  This list is sorted by language, then by order
in the @code{PATH} environment variable (so that compilers that you
are more likely to use appear first), then by runtime names and
finally by version of the compiler.  The idea is that the first
compiler for any language is the most likely one you want to use.

Selection is done by entering the letter that appears on the line for
each compiler. If the compiler was already selected, it is deselected.

The list of compilers is then displayed again, but some filtering has been
performed: only compilers that target the same platform as the selected
compiler are now displayed. @code{gprconfig} then checks whether it is
possible to link sources compiled with the selected compiler and each of
the remaing compiler; when linking is not possible, the compiler is not
displayed. Likewise, all compilers for the same language are hidden, so that
you can only select one compiler per language. If you need to compile your
application with several C compilers for instance, you should create another
language, for instance called C2, for that purpose. That will give you the
flexibility to indicate in the project files which compiler should be used
for which sources.

The goal of this filtering is to make it more obvious whether you have
good chances of being able to link. There is however no guarantee that
@code{gprconfig} will know for sure how to link any combination of the
remaining compilers.

In the list, if you select "o", @code{gprconfig} will let you enter
information about a compiler that was not found automatically:
@itemize @bullet
@item Name

In the knowledge base of @code{gprconfig}, each compiler is associated
with a simple name. All the known names are listed next to the question.
If your compiler is one of the known ones, enter the name. You can also
enter any other name, but then @code{gprconfig} will not be able to
guess any of the remaining info.

@item Path

This is the directory that contains the executable of your compiler, not
including the name of the compiler itself. For instance, for a GNAT
compiler installed in @file{/usr/local/gnat/bin/gnatmake}, the path would be
@file{/usr/local/gnat/bin}.

@item Version

The version of your compiler. If the Name you provided is one of the known
compilers, @code{gprconfig} will try to guess it for you, so that you can
simply press enter if the guess is valid.

@item Language

The language that you intend to use the compiler for. If you use the same
compiler for multiple languages, you should enter only one of these at
this point, and later on create a new compiler entry for the other
languages. As for Version, @code{gprconfig} will try to guess it for you
if it is one of the known compilers.

@item Runtime

The runtime you intend to use for this compiler. For most languages, this
is not applicable, and you should simply press Enter. Once again,
@code{gprconfig} will try to guess it if possible.

@item Target

The target architecture for which the compiler is compiling. @code{gprconfig}
will try to guess it either from the compiler you pointed to, or will by
default use the current system's architecture, assuming this is not a
cross compiler.
@end itemize

You can select as many compilers as are used in your application. Once you
are done selecting the compilers, select "s", and @code{gprconfig} will
generate the configuration file.

@subsection Command line switches

The following command line switches are supported by @code{gprconfig}.

@itemize @bullet
@item -o file

The name of the output file. By default, @code{gprconfig} will search for
@code{gprbuild} on your PATH, and create a default configuration file for
it. But you can alternatively choose to create a different configuration
file and then use @code{gprbuild}'s command line switches to choose among
these.

@item --db directory

Indicates another directory that should be parsed for gprconfig's knowledge
base. Most of the time this is only useful if you are creating your own
XML description files.

@item --db -

Prevents @code{gprconfig} from reading its default knowledge base. You
should point to another directory with @code{--db directory}, or
gprconfig will not be able to generate any configuration file.

@item --target target

Specify the target for the compilers.  Only compilers generating code for
this target will be preselected.  By default the target is the host.  If
target is all, any target is accepted.  The name of the host target is
displayed in the help.

@item --show-targets

Simply displays the target of all compilers found and exit.

@item --config language[,version[,runtime[,path[,name]]]]

This parameter is used to preselect configurations.
"name" should be one of the known compiler names (e.g. "GNAT", "GCC",...), the
full list of which is visible when gprconfig is used interactively and you add
a custom compiler. However, you can use an unknown name, but in this case you
need to provide all the information yourself.

"path" is the directory that contains the compiler executable, for instance
@file{/usr/bin} (and not the installation prefix @file{/bin}).

If "name" is a known compiler name, the remaining attributes will have defaults
computed automatically by @code{gprconfig}. You can either specify them, or
use an empty string to get the default value and specify a later parameter.

@smallexample
  gprconfig --config Ada,,,/usr/bin       # automatic parameters
  gprconfig --config C,,,/usr/bin,C       # automatic version
@end smallexample

@item --batch

If this parameter is specified, @code{gprconfig} doesn't go into its
interactive compiler selection, but generates the output configuration file
directly from the compilers selected with the @code{--config} command line
switch.

@item -h

Display help for @code{gprconfig} switches.
@end itemize

@c ----------------------------------------------------------------------
@node Description of the knowledge base
@section Description of the knowledge base
@c ----------------------------------------------------------------------


@noindent
@code{gprconfig} itself has no hard-coded knowledge of compilers. This way,
no new version of gprconfig needs to be recompiled whenever a new compiler
is distributed.

All its knowledge is embedded in a set of XML files, call the knowledge
base. Users can easily contribute to this general knowledge base, and have
@code{gprconfig} immediately take advantage of this.

The knowledge base contains various kind of information:
@itemize @bullet
@item Compiler description

   When it is run interactively, @code{gprconfig} will search on the user's
   @code{PATH} for known compilers, and try to automatically guess their
   configuration (version, supported languages, supported targets, runtimes,
   @dots{}).

   This step is optional, since a user can also enter all the information
   manually. However, it is recommended that the knowledge base explicitly
   lists its known compilers to make configuration easier for end users.

@item Specific compilation switches

   When a compiler is used, depending on its version, target, runtime,@dots{},
   some specific command line switches might have to be enforced. The
   knowledge base is a good place to store such information once and for all.

   For instance, with the GNAT compiler, using the soft-float runtime should
   force @code{gprbuild} to use the @code{-msoft-float} compilation switch.

@item Linker options

   Linking a multi-language application is often tricky, and requires specific
   linker switches. These switches depend on the list of languages, the list
   of compilers,@dots{}.

@item Unsupported compiler mix

   It is sometimes not possible to link together code compiled with two
   compilers. The knowledge base should store this information, so that end
   users do not waste time trying to use that compiler combination.

@end itemize

@c ------------------------------------------------------------------------
@node General file format
@section General file format
@c ------------------------------------------------------------------------

@noindent
The knowledge base is implemented as a set of XML files. None of these
files have a special name, nor a special role. Instead, the user can
freely create new files, and put them in the knowledge base directory,
to contribute new knowledge.

The location of the knowledge base is @file{$prefix/share/gprconfig},
where @file{$prefix} is the directory in which @code{gprconfig} was
installed. Any file with extension @file{.xml} in this directory will
be parsed automatically by gprconfig at startup.

All files must have the following format:

@smallexample
<?xml version="1.0">
<gprconfig>
   ...
</gprconfig>
@end smallexample

The XML parser used by @code{gprconfig} is very simple minded, and does not
support advanced XML constructs. In fact, it also has a few limitation
with regards to comments (for instance they cannot contain the '>'
character).

The root tag must be @code{<gprconfig>}.

The remaining sections in this chapter will list the valid XML tags that
can be used to replace the '...' code above. These tags can either all be
put in a single XML files, or split in several files.

@c ------------------------------------------------------------------------
@node Compiler description
@section Compiler description
@c ------------------------------------------------------------------------

@noindent
One of the XML tags that can be put as a child of @code{<gprconfig>} is
@code{<compiler_description>}. This node and its children describe one of
the compilers known to @code{gprconfig}. The tool uses them when it
initially looks for all compilers known on the user's @code{PATH}
environment variable.

This is optional information, but simplifies the use of @code{gprconfig}.

This node doesn't accept any XML attribute. However, it accepts a number
of child tags that explain how to query the various attributes of the
compiler.

@itemize @bullet
@item @code{<name>}

This tag contains a simple string, which is the name of the compiler.
This name must be unique in all the configuration files, and is used to
identify that compiler_description node.

@smallexample
<compiler_description>
   <name>GNAT</name>
</compiler_description>
@end smallexample

@item @code{<executable>}

This tag contains a string, which is the name of an executable
to search for on the PATH. Examples are @file{"gnatls"}, @file{"gcc}",
@dots{}

In some cases, the tools have a common suffix, but a prefix that might depend
on the target. For instance, GNAT uses "gnatmake" for native platforms, but
"powerpc-wrs-vxworks-gnatmake" for cross-compilers to vxworks. Most of the
compiler description is the same, however.

For such cases, this tag must specify a "prefix" attribute, and its value is
assumed to be a regular expression. This allows you to capture the prefix and
reuse it elsewhere.

When you intend to reuse the prefix, you must set the XML attribute "prefix"
to the parenthesis group that matches this prefix. In the following example,
we get the version of the GNAT compiler by running either "gnatls" or
"powerpc-wrs-vxworks-gnatls", depending on the name of the executable that
was found.

The regular expression need to match the whole name of the file, ie it
contains an implicit "^" at the start, and an implicit "$" at the end.
Therefore if you specify ".*gnatmake" as the regexp, it will not match
"gnatmake-debug".

@smallexample
<executable prefix="1">(powerpc-wrs-vxworks-)?gnatmake</executable>
<version><external>$@{PREFIX@}gnatls -v</external></version>
@end smallexample

@code{gprconfig} searches in all directories listed on the PATH for such
an executable. When one is found, the rest of the @code{<compiler_description>}
children is checked to know whether the compiler is valid. The directory
in which the executable was found becomes the "current directory" for
the remaining XML children.

@item @code{<version>}

This tag contains any of the nodes defined in "external values" below.
It shows how to query the version number of the compiler. If the version
cannot be found, the executable will not be listed in the list of compilers.
The value returned by the system will be split into words. As a result, if
the returned value is "ada,c,c++", there are three languages supported by the
compiler. The words can be comma-separated or space-separated.

If you use have several child nodes, the first one will be used to set the
special @code{$VERSION} substitution string (see External Values below), and
the second will be used to defined the special @code{$VERSION2} substitution
string.

@item @code{<languages>}

This node indicates how to query the list of languages. See "External values"
below for valid children of this node. The returned value is a comma-separated
or space-separated list of languages.

@item @code{<runtimes>}

This node indicates how to query the list of supported runtimes for the
compiler. See "External values" below for valid children. The returned value
is split into words as for @code{<languages>}.

@item @code{<target>}

This node indicates how to query the target architecture for the compiler.
See "External values" below for valid children.

@item @code{<extra_tool>}

This node contains the name of an extra tool to run if the compiler is
selected by the user. Typically, it can be used to generate a user-visible
project file for the user, like @file{ada_runtime.gpr}. This attribute is
the full command line used to launch the tool, where special substrings like
"$OUTPUT_DIR",... will be automatically substituted (see External Values
below for the full list of such special substrings)

@end itemize

@c --------------------------------------------------------------------
@subsection External values
@c --------------------------------------------------------------------
@noindent
A number of the XML nodes described above can contain one or more children,
and explain how to query a value from the executable. Here is the list of
valid contents for these nodes. The @code{<directory>} and @code{<external>}
children can be repeated multiple times, and the @code{<filter>} and
@code{<must_match>} nodes will be applied to each of these. The final
value of the external value is the sum of the computation for each of the
@code{<directory>} and @code{<external>} nodes.

@itemize @bullet
@item A simple string

When a simple string is given in the node, this indicates a constant. For
instance, the list of supported languages might be defined as:

@smallexample
<compiler_description>
   <name>GNAT</name>
   <executable>gnatls</executable>
   <languages>Ada</languages>
</compiler_description>
@end smallexample

for the GNAT compiler, since this is an Ada only compiler anyway.

@item @code{<external match="regexp" group="0">command</external>}

If the contents of the node is an @code{<external>} child, this indicates
that a command should be run on the system, and its output parsed.
When the command is run, the current directory (ie the one that contains
the executable found through the @code{<executable>} node, is put first
on the PATH. The output of the command is matched again the regular
expression @code{regexp}. Finally, the parenthesis group specified by
@code{group} is returned. By default, group is 0, which indicates the
whole output of the command.

For instance, extracting the version number from @code{gcc} can be done
with:

@smallexample
<version>
   <external regexp="^gcc version (\S+)" group="1">gcc -v</external>
</version>
@end smallexample

Since the PATH has been modified, we know that the @code{gcc} command that
is executed is the one from the same directory as the @code{<external>}
node.

@item @code{<directory group="0">regexp</directory>}

If the contents of the node is a @code{<directory}> child, this
indicates that @code{gprconfig} should find all the files matching the
regular expression. Regexp is a path relative to the directory that contains
the @code{<executable>} file, and should use unix directory separators
(ie '/'), since the actual directory will be converted into this format
before the match, for system independence of the knowledge base. Special
constructs can be specified in the regexp:

@itemize -
@item "$@{EXEC@}" is the name of the executable that was found through
      @code{<executable>}. It only contains the basename, not the directory
      information.
@item "$@{HOST@}"  is replaced by the architecture of the host on which
      gprconfig is running. This name is hard-coded in gprconfig itself,
      and is generated by @code{configure} when gprconfig was build.
@item "$@{TARGET@}" is replaced by the target architecture of the compiler,
      as returned by the @code{<target>} node. This is of course not available
      when computing the target itself
@item "$@{VERSION@}" is replaced by the version of the compiler. This is not
      available when computing the target or, of course, the version itself.
@item "$@{VERSION2@}" is replaced by the second version of the compiler. Some
      compilers depend on other tools (like GNAT depends on gcc), and this
      version might for instance contain the version number for these other
      tools. The exact semantic, though, depends on the @code{<version>} node.
@item "$@{PREFIX@}" is replaced by the prefix to the executable name, as
      defined by the @code{<executable>} node.
@item "$@{PATH@}" is the current directory, ie the one containing the executable
      found through @code{<executable>}. It always ends with a directory
      separator.
@item "$@{GPRCONFIG_PREFIX@}" is the directory in which gprconfig
      was installed (e.g @file{"/usr/local/"} if the executable is
      @file{"/usr/local/bin/gprconfig"}. This directory always ends with a
      directory separator.
@item "$@{RUNTIME@}", "$@{RUNTIME_DIR@}", "$@{LANGUAGE@}", "$@{OUTPUT_DIR@}"
      This string will always be substituted by the empty string when the
      value of the external value is computed. These are special strings
      used when substituting text in configuration chunks.
      OUTPUT_DIR and RUNTIME_DIR always end with a directory separator.
@item "regexp" can be any valid regular expression. This will only match
      a directory name, not a subdirectory. Remember to quote special
      characters, including ".", if you do not mean to use a regexp.
@end itemize

The group attribute indicates which parenthesis group should be returned.
It defaults to 0 which indicates the whole matched path. If this attribute is
not an integer, but a string, then it is the value returned.

For instance, finding the list of supported runtimes for the GNAT compiler
is done with:

@smallexample
<runtimes>
 <directory group="1">\.\./lib/gcc/$@{TARGET@}/.*/rts-(.*)/adainclude</directory>
 <directory group="default">\.\./lib/gcc/$@{TARGET@}/.*/adainclude</directory>
</runtimes>
@end smallexample

Note the second node, which matches the default runtime, and displays it as
such.

@item @code{<filter>value1,value2,...</filter>}

This node must come after one the previously described ones. It is used to
further filter the output. The previous output is split into words (it is
considered as a comma-separated or space-separated list of words), and only
those words in "value1", "value2",... is kept.

For instance, the @code{gcc} compiler will return a lot of supported
languages, including "ada". If we do not want to use it as an Ada
compiler, so we can put:

@smallexample
<languages>
   <external regexp="languages=(\S+)" group="1">gcc -v</external>
   <filter>c,c++,fortran</filter>
</languages>
@end smallexample

@item @code{<must_match>regexp</must_match>}

If this node is present, then the filtered output is compared with the
specified regular expression. If no match is found, then the executable
is not stored in the list of known compilers.

For instance, if one wants to have a @code{<compiler_description>} tag
specific to an older version of GCC, we could write:

@smallexample
<version>
   <external regexp="gcc version (\S+)" group="1">gcc -v </external>
   <must_match>2.8.1</must_match>
</version>
@end smallexample

Other versions of gcc will not match this @code{<compiler_description>}
node.

@end itemize

@c ------------------------------------------------------------------------
@node Configurations
@section Configurations
@c ------------------------------------------------------------------------

@noindent
The second type of information stored in the knowledge base are the chunks
of @code{gprbuild} configuration files.

Each of these chunks is also put in an XML node, that provides optional
filters. If all the filter match, then the chunk will be merged with other
similar chunks and put in the final configuration file that is generated
by @code{gprconfig}.

For instance, it is possible to indicate that a chunk should only be
included if the GNAT compiler with the soft-float runtime is used. Such
a chunk can for instance be used to ensure that Ada sources are always
compiled with the @code{-msoft-float} command line switch.

@code{gprconfig} doesn't do intelligent merging of chunks. All it does
is group packages together. For instance, if the two chunks are:

@smallexample
chunk1:
   package Language_Processing is
     for Attr1 use ("foo");
   end Language_Processing;
chunk2:
   package Language_Processing is
     for Attr1 use ("bar");
   end Language_Processing;
@end smallexample

Then the final configuration file will look like:

@smallexample
   package Language_Processing is
      for Attr1 use ("foo");
      for Attr1 use ("bar");
   end Language_Processing;
@end smallexample

As a result, to avoid conflicts, it is recommended that the chunks be
written so that they they easily collaborate together. For instance, if we
want to obtain something equivalent to
@smallexample
   package Language_Processing is
      for Attr1 use ("foo", "bar");
   end Language_Processing;
@end smallexample
the two chunks above should be written as:
@smallexample
chunk1:
   package Language_Processing is
      for Attr1 use Language_Processing'Attr1 & ("foo");
   end Language_Processing;
chunk2:
   package Language_Processing is
      for Attr1 use Language_Processing'Attr1 & ("bar");
   end Language_Processing;
@end smallexample

The chunks are described in an @code{<configuration>} XML node. The most
important child of such a node is @code{<config>}, which contains the
chunk itself. For instance, one would write:

@smallexample
<configuration>
  ...  list of filters, see below
  <config>
   package Language_Processing is
      for Attr1 use Language_Processing'Attr1 & ("foo");
   end Language_Processing;
  </config>
</configuration>
@end smallexample

If @code{<config>} is an empty node (ie "<config/>" or "<config></config>")
was used, then the combination of selected compilers will be reported as
invalid, in the sense that we know that code compiled with these compilers
cannot be linked together. As a result, @code{gprconfig} will not create
the configuration file.

When the @code{<configuration>} node has a single @code{<compilers>}
child, special substrings are substituted in the chunk. These are the same as
described for External Values in a previous section, ie "$RUNTIME",
"$PATH", "$RUNTIME_DIR", "$OUTPUT_DIR", "$VERSION", "$LANGUAGE", "$HOST"
and "$TARGET". Their
values are those of the first compiler in @code{<compilers>} that matched.
"$OUTPUT_DIR" is the directory in which the generated configuration file will
be created.

The filters themselves are of course defined through XML tags, and can
be any of:

@itemize @bullet
@item @code{<compilers negate="false">}

This filter contains a list of @code{<compiler>} children. The
@code{<compilers>} filter matches if any of its children match.
However, you can have several @code{<compilers>} filters, in which
case they must all match. This can be used to include linker switches
chunks. For instance, the following code would be used to describe
the linker switches to use when GNAT 5.05 or 5.04 is used in addition to
g++ 3.4.1:

@smallexample
<configuration>
  <compilers>
    <compiler name="GNAT" version="5.04" />
    <compiler name="GNAT" version="5.05" />
  </compilers>
  <compilers>
    <compiler name="G++" version="3.4.1" />
  </compilers>
  ...
</configuration>
@end smallexample

If the attribute "negate" is "true", then the meaning of this filter is
inverted, and it will match if none of its children matches.

The format of the @code{<compiler>} is the following:
@smallexample
   <compiler name="name" version="..." runtime="..." language="..." />
@end smallexample

The name & language attributes, when specified, match
the corresponding attributes used in the @code{<compiler_description>}
children. All other attributes are regular expressions, that are matched
against the corresponding selected compilers. When an attribute is not
specified, it will always match. Matching is done in a case-insensitive
manner.
For instance, to check a GNAT compiler in the 5.x family, use:

@smallexample
   <compiler name="GNAT" version="5.\d+" />
@end smallexample

@item @code{<hosts negate="false">}

This filter contains a list of @code{<host>} children. It matches when
any of its children matches. You can specificy only one @code{<hosts>}
node.
The format of @code{<host>} is a node with a single mandatory attribute
@code{"name"}, which is a regexp matched against the architecture on
which @code{gprconfig} is running. The name of the architecture was
computed by @code{configure} when @code{gprconfig} was build.

If the "negate" attribute is "true", then the meaning of this filter is
inverted, and it will match when none of its children matches.

For instance, to active a chunk only if the compiler is running on an
intel linux machine, use:

@smallexample
   <hosts>
      <host name="i.86-.*-linux(-gnu)?" />
   </hosts>
@end smallexample

@item @code{<targets negate="false">}

This filter contains a list of @code{<target>} children. It behaves
exactly like @code{<hosts>}, but matches against the architecture
targeted by the selected compilers. For instance, to activate a chunk
only when the code is targeted for linux, use:

If the "negate" attribute is "true", then the meaning of this filter is
inverted, and it will match when none of its children matches.

@smallexample
   <targets>
      <target name="i.86-.*-linux(-gnu)?" />
   </targets>
@end smallexample
@end itemize

@c  ------------------------------------------------------------------------
@node Configuration File Reference
@chapter Configuration File Reference
@c  ------------------------------------------------------------------------

@menu
* Project Level Attributes::
* Package Naming::
* Package Builder::
* Package Compiler::
* Package Binder::
* Package Linker::
@end menu

@noindent
gprbuild needs to have a configuration file to know the different
characteristics of the toolchains that can be used to compile sources and
build libraries and executables.

A configuration file is a special kind of project file: it uses the same
syntax as a standard project file. Attributes in the configuration file
define the configuration. Some of these attributes have a special meaning
in the configuration.

The default name of the configuration file, when to specified to gprbuild by
switch --config= is "default.cgpr". Although the name of the configuration
file can be any valid file name, it is recommended that its suffix be ".cgpr" (for
Configuration GNAT Project), so that it cannot be confused with a standard
project file which has the suffix ".gpr".

In the description of the attributes that follows, when an attribute is an
associative array indexed by the language name, for example
Spec_Suffix (<language>), then the name of the language is case insensitive.
For example, "C" and "c" are allowed.

@node Project Level Attributes
@section Project Level Attributes

@menu
* General Attributes::
* General Library Related Attributes::
* Archive Related Attributes::
* Shared Library Related Attributes::
@end menu

@node General Attributes
@subsection General Attributes

@itemize @bullet

@item Default_Language

Specifies the name of the language of the immediate sources of a project when
attribute Languages is not declared in the project. If attribute
Default_Language is not declared in the configuration file, then all user
project files in the project tree must have an attribute Languages declared
except when the extend another project. Example:

@smallexample
   for Default_Language use "ada";
@end smallexample

@item Run_Path_Option

Specifies a "run path option", that is an option to use when linking an
executable or a shared library to indicate the path where to look for other
libraries. The value of this attribute is a string list. When linking an
executable or a shared library, the search path is concatenated with the last
string in the list, which may be an empty string. Example:

@smallexample
   for Run_Path_Option  use ("-Wl,-rpath,");
@end smallexample

@item Toolchain_Version (<language>)

Specifies a version for a toolchain, as a single string. This toolchain
version is passed to the library builder. Example:

@smallexample
   for Toolchain_Version ("Ada") use "GNAT 6.1";
@end smallexample

@item Toolchain_Description (<language>)

Specifies as a single string a description of a toolchain. This attribute is
not directly used by gprbuild or its auxiliary tools (gprbind and gprlib) but
may be used by other tools, for example GPS. Example:

@smallexample
   for Toolchain_Description ("C") use "gcc version 4.1.3 20070425";
@end smallexample

@end itemize

@node General Library Related Attributes
@subsection General Library Related Attributes

@itemize @bullet

@item Library_Support

Specifies the level of support for library project. If this attribute is not
specified, then library projects are not supported. The only potential values
for this attribute are "none", "static_only" and "full". Example:

@smallexample
   for Library_Support use "full";
@end smallexample

@item Library_Builder

Specifies the name of the executable for the library builder. Example:

@smallexample
   for Library_Builder use "/.../gprlib";
@end smallexample

@end itemize

@node Archive Related Attributes
@subsection Archive Related Attributes

@itemize @bullet

@item Archive_Builder

Specifies the name of the executable of the archive builder with the minimum
options, if any. Example:

@smallexample
   for Archive_Builder use ("ar", "cr");
@end smallexample

@item Archive_Indexer

Specifies the name of the executable of the archive indexer with the minimum
options, if any. If this attribute is not specified, then there is no
archive indexer. Example:

@smallexample
   for Archive_Indexer use ("ranlib");
@end smallexample

@item Archive_Suffix

Specifies the suffix of the archives. If this attribute is not specified, then
the suffix of the archives is defaulted to ".a". Example:

@smallexample
   for Archive_Suffix use ".olb"; --  for VMS
@end smallexample

@item Library_Partial_Linker

Specifies the name of the executable of the partial linker with the options
to be used, if any. If this attribute is not specified, then there is no
partial linking. Example:

@smallexample
   for Library_Partial_Linker use ("gcc", "-nostdlib", "-Wl,-r", "-o");
@end smallexample

@end itemize

@node Shared Library Related Attributes
@subsection Shared Library Related Attributes

@itemize @bullet

@item Shared_Library_Prefix

Specifies the prefix of the file names of shared libraries. When this attribute
is not specified, the prefix is "lib". Example:

@smallexample
   for Shared_Library_Prefix use ""; --  for Windows
@end smallexample

@item Shared_Library_Suffix

Specifies the suffix of the file names of shared libraries. When this attribute
is not specified, the prefix is ".so". Example:

@smallexample
   for Shared_Library_Suffix use ".dll"; --  for Windows
@end smallexample

@item Symbolic_Link_Supported

Specifies if symbolic links are supported by the platforms. The possible values
of this attribute are "false" (the default) and "true". When this attribute is
not specified, symbolic links are not supported.

@smallexample
   for Symbolic_Link_Supported use "true";
@end smallexample

@item Library_Major_Minor_ID_Supported

Specifies if major and minor IDs are supported for shared libraries.
The possible values of this attribute are "false" (the default) and "true".
When this attribute is not specified, major and minor IDs are not supported.

@smallexample
   for Library_Major_Minor_ID_Supported use "True";
@end smallexample

@item Library_Auto_Init_Supported

Specifies if library auto initialization is supported. The possible values of
this attribute are "false" (the default) and "true". When this attribute is not
specified, library auto initialization is not supported.

@smallexample
   for Library_Auto_Init_Supported use "true";
@end smallexample

@item Shared_Library_Minimum_Switches

Specifies the minimum options to be used when building shared library. These
options are put in the appropriate section in the library exchange file when
the library builder is invoked. Example:

@smallexample
   for Shared_Library_Minimum_Switches use  ("-shared");
@end smallexample

@item Library_Version_Switches

Specifies the option or options to be used when a library version is used.
These options are put in the appropriate section in the library exchange file
when the library builder is invoked. Example:

@smallexample
   for Library_Version_Switches use ("-Wl,-soname,");
@end smallexample

@end itemize

@node Package Naming
@section Package Naming

Attributes in package Naming of a configuration file specify defaults. These
attributes may be used in user project files to replace these defaults.

The following attributes may appear in package Naming of a configuration file:

@itemize @bullet
@item Spec_Suffix (<language>)

Specifies the default suffix for a "spec" or header file. Examples:

@smallexample
   for Spec_Suffix ("Ada") use ".ads";
   for Spec_Suffix ("C")   use ".h";
   for Spec_Suffix ("C++") use ".hh";
@end smallexample

@item Body_Suffix (<language>)

Specifies the default sufix for a "body" or a source file. Examples:

@smallexample
   for Body_Suffix ("Ada") use ".adb";
   for Body_Suffix ("C")   use ".c";
   for Body_Suffix ("C++") use ".cpp";
@end smallexample

@item Separate_Suffix

Specifies the suffix for a subunit source file (separate) in Ada. If attribute
Separate_Suffix is not specified, then the default suffix of subunit source
files is the same as the default suffix for body source files. Example:

@smallexample
   for Separate_Suffix use ".sep";
@end smallexample

@item Casing

Specifies the casing of spec and body files in a unit based language
(such as Ada) to know how to map a unit name to its file name. The values for
this attribute may only be "lowercase", "UPPERCASE" and "Mixedcase".
The default, when attribute Casing is not specified is lower case.
It is rarely the case when this attribute needs to be specified, as on
platforms where file names are not case sensitive (such as Windows of VMS)
the default (lower case) will work fine.

@item Dot_Replacement

Specifies the string to replace a dot ('.') in unit name of a unit based
language (such as Ada) to obtain its file name. If there is any unit based
language in the configuration, attribute Dot_Replacement must be declared.
Example:

@smallexample
   for Dot_Replacement use "-";
@end smallexample

@end itemize

@node Package Builder
@section Package Builder

@itemize @bullet

@item Executable_Suffix

Specifies the default executable suffix. If no attribute Executable_Suffix is
declared, then the default executable suffix for the host platform is used.
Example:

@smallexample
   for Executable_Suffix use ".exe";
@end smallexample

@end itemize

@node Package Compiler
@section Package Compiler

@menu
* General Compilation Attributes::
* Mapping File Related Attributes::
* Config File Related Attributes::
* Dependency Related Attributes::
* Search Path Related Attributes::
@end menu

@node General Compilation Attributes
@subsection General Compilation Attributes

@itemize @bullet

@item Driver (<language>)

Specifies the name of the executable for the compiler of a language. The single
string value of this attribute may be an absolute path or a relative path. If
relative, then the execution path is searched. Examples:

@smallexample
   for Driver ("C++") use "g++";
   for Driver ("Ada") use "/.../bin/gcc";
@end smallexample

@item Switches (<language>)

Specifies the minimum options that must be used when invoking the compiler
of a language. Examples:

@smallexample
   for Switches ("C")   use ("-c", "-x", "c");
   for Switches ("Ada") use ("-c", "-x", "ada", "-gnatA");
@end smallexample

@item PIC_Option (<language>)

Specifies the option or options that must be used when compiling a source of
a language to be put in a shared library. Example:

@smallexample
   for PIC_Option ("C") use ("-fPIC");
@end smallexample

@end itemize

@node Mapping File Related Attributes
@subsection Mapping File Related Attributes

@itemize @bullet

@item Mapping_File_Switches (<language>)

Specifies the switch or switches to be used to specify a mapping file to the
compiler. When attribute Mapping_File_Switches is not declared, then no
mapping file is specified to the compiler. The value of this attribute is a
string list. The path name of the mapping file is concatenated with the last
string in the string list, which may be empty. Example:

@smallexample
   for Mapping_File_Switches ("Ada") use ("-gnatem=");
@end smallexample

@item Mapping_Spec_Suffix (<language>)

Specifies, for unit based languages that support mapping files, the suffix in
the mapping file that needs to be added to the unit name for specs. Example:

@smallexample
    for Mapping_Spec_Suffix ("Ada") use "%s";
@end smallexample

@item Mapping_Body_Suffix (<language>)

Specifies, for unit based languages that support mapping files, the suffix in
the mapping file that needs to be added to the unit name for bodies. Example:

@smallexample
    for Mapping_Spec_Suffix ("Ada") use "%b";
@end smallexample

@end itemize

@node Config File Related Attributes
@subsection Config File Related Attributes

@noindent

In the value of config file attributes defined below, there are some
placeholders that gprbuild will replace. These placeholders are:

@itemize @bullet

@item %u : the unit name

@item %f : the file name of the source

@item %s : the spec suffix

@item %b : the body suffix

@item %c : the casing

@item %d : the dot replacement string

@end itemize

Attributes:

@itemize @bullet

@item Config_File_Switches (<language>)

Specifies the switch or switches to be used to specify a confi file to the
compiler. When attribute Config_File_Switches is not declared, then no
config file is specified to the compiler. The value of this attribute is a
string list. The path name of the config file is concatenated with the last
string in the string list, which may be empty. Example:

@smallexample
   for Config_File_Switches ("Ada") use ("-gnatec=");
@end smallexample

@item Config_Body_File_Name (<language>)

Specifies the line to be put in a config file to indicate the file name of a
body. Example:

@smallexample
   for Config_Body_File_Name ("Ada") use
       "pragma Source_File_Name_Project (%u, Body_File_Name => ""%f"");";
@end smallexample

@item Config_Spec_File_Name (<language>)

Specifies the line to be put in a config file to indicate the file name of a
spec. Example:

@smallexample
   for Config_Spec_File_Name ("Ada") use
       "pragma Source_File_Name_Project (%u, Spec_File_Name => ""%f"");";
@end smallexample

@item Config_Body_File_Name_Pattern (<language>)

Specifies the line to be put in a config file to indicate a body file name
pattern. Example:

@smallexample
   for Config_Body_File_Name_Pattern ("Ada") use
       "pragma Source_File_Name_Project " &
       "  (Body_File_Name  => ""*%b""," &
       "   Casing          => %c," &
       "   Dot_Replacement => ""%d"");";
@end smallexample

@item Config_Spec_File_Name_Pattern (<language>)

Specifies the line to be put in a config file to indicate a spec file name
pattern. Example:

@smallexample
   for Config_Spec_File_Name_Pattern ("Ada") use
       "pragma Source_File_Name_Project " &
       "  (Spec_File_Name  => ""*%s""," &
       "   Casing          => %c," &
       "   Dot_Replacement => ""%d"");";
@end smallexample

@item Config_File_Unique (<language>)

Specifies, for languages that support config files, if several config files
may be indicated to the compiler, or not. This attribute may have only two
values: "true" or "false" (case insensitive). The default, when this attribute
is not specified, is "false". When the value "true" is specified for this
attribute, gprbuild will concatenate the config files, if there are more than
one. Example:

@smallexample
   for Config_File_Unique ("Ada") use "True";
@end smallexample

@end itemize

@node Dependency Related Attributes
@subsection Dependency Related Attributes

@itemize @bullet

@item Dependency_Switches (<language>)

For languages other than Ada, attribute Dependency_Switches specifies
the option or options to add to the compiler invocation so that it creates
the dependency file at the same time. The value of attribute Dependency_Option
is a string list. The name of the dependency file is added to the last string
in the list, which may be empty. Example:

@smallexample
   for Dependency_Switches ("C") use ("-Wp,-MD,");
@end smallexample

With this Dependency_Option, when compiling "file.c", the compiler will be
invoked with the option "-Wp,-MD,file.d".

@item Compute_Dependency (<language>)

Specifies the command and options to create a dependency file for a source.
The full path name of the source is appended to the last string of the string
list value. Example:

@smallexample
   for Compute_Dependency ("C") use ("gcc", "-E", "-Wp,-M", "");
@end smallexample

Attributes Dependency_Option and Compute_Dependency are mutually exclusive.

@end itemize

@node Search Path Related Attributes
@subsection Search Path Related Attributes

@itemize @bullet

@item Include_Switches (<language>)

Specifies the option or options to use when invoking the compiler to indicate
that a directory is part of the source search path. The value of this
attribute is a string list. The full path name of the directory is concatenated
with the last string in the string list, which may be empty. Example:

@smallexample
   for Include_Switches ("C") use ("-I");
@end smallexample

Attribute Include_Switches is ignored if either one of the attributes
Include_Path or Include_Path_File are specified.

@item Include_Path (<language>)

Specifies the name of an environment variable that is used by the compiler to
get the source search path. The value of the environment variable is the source
search path to be used by the compiler. Example:

@smallexample
   for Include_Path ("C")   use "CPATH";
   for Include_Path ("Ada") use "ADA_INCLUDE_PATH";
@end smallexample

Attribute Include_Path is ignored if attribute Include_Path_File is declared
for the language.

@item Include_Path_File (<language>)

Specifies the name of an environment variable that is used by the compiler to
get the source search path. The value of the environment variable is the path
name of a text file that contain the path names of the directories of the
source search path. Example:

@smallexample
   for Include_Path_File ("Ada") use "ADA_PRJ_INCLUDE_FILE";
@end smallexample

@end itemize

@node Package Binder
@section Package Binder

@itemize @bullet

@item Driver (<language>)

Specifies the name of the executable of the binder driver. When this attribute
is not specified, there is no binder for the language. Example:

@smallexample
   for Driver ("Ada") use "/.../gprbind";
@end smallexample

@item Switches (<language>)

Specifies the minimum options to be used when invoking the binder driver.
These options are put in the appropriate section in the binder exchange file,
one option per line. Example:

@smallexample
   for Switches ("Ada") use ("--prefix=<prefix>");
@end smallexample

@item Prefix (<language>)

Specifies the prefix to be used in the name of the binder exchange file.
Example:

@smallexample
   for Prefix ("C++") use ("c__");
@end smallexample

@item Objects_Path (<language>)

Specifies the name of an environment variable that is used by the compiler to
get the object search path. The value of the environment variable is the object
search path to be used by the compiler. Example:

@smallexample
   for Objects_Path ("Ada") use "ADA_OBJECTS_PATH";
@end smallexample

@item Objects_Path_File (<language>)

Specifies the name of an environment variable that is used by the compiler to
get the object search path. The value of the environment variable is the path
name of a text file that contain the path names of the directories of the
object search path. Example:

@smallexample
   for Objects_Path_File ("Ada") use "ADA_PRJ_OBJECTS_FILE";
@end smallexample

@end itemize

@node Package Linker
@section Package Linker

@itemize @bullet

@item Driver

Specifies the name of the executable of the default linker. Example:

@smallexample
   for Driver use "g++";
@end smallexample

@item Required_Switches

Specifies the minimum options to be used when invoking the default linker.

@end itemize

Index


@c  --------------------------------------------------------------------------
@node Index
@c  --------------------------------------------------------------------------

@unnumbered Index

@c @printindex cp

@contents

@bye

