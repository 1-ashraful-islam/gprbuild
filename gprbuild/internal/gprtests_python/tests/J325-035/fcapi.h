/*********************************************************************************************

    COPYRIGHT CRITICAL I/O, LLC.  ALL RIGHTS RESERVED

    FILE NAME :             FCAPI.h    $Revision: 1.7 $
    Module Description:     Common definitions for FC2100 API

  Special Notes:
    **** Do not change any definitions in this file ****

  Revision History
    Date        Description of Change
    ---------   ------------------------
    7/10/98     Version 1.0
    8/28/98     Version 2.0 See rel2_0.txt
    10/5/98     Version 2.1 See rel2_1.txt
    3/19/99     Version 2.2 See rel2_2.txt
    5/20/99     Version 2.3 See rel2_3.txt
    10/1/99     Version 3.0 See rel3_0.txt
    01/21/00    Version 3.11 See rel3_11.txt
    09/18/00    Version 3.2 See rel3_2.txt
    11/09/01    Version 4.0 See rel4_0.txt
    05/20/02    Version 4.1 See rel4_1.txt
    12/13/02    Version 4.5 See rel4_5.txt
    12/19/05    Version 6.0 See rel6_0.txt
        
  ************************************************************************
  *                                                                      *
  *                              NOTICE                                  *
  *                                                                      *
  *            COPYRIGHT 2000, 2001, 2002, 2003, 2004, 2005				 *
  *							 Critical IO, INC               			 *
  *                          ALL RIGHTS RESERVED                         *
  *                                                                      *
  * This computer program is CONFIDENTIAL  and contains TRADE SECRETS of *
  * CRITICAL IO, INC.  The  receipt or possession of this program        *
  * does not convey any rights to reproduce or disclose  its contents,   *
  * or to manufacture, use, or sell anything that it may describe, in    *
  * whole or in part, without the specific written consent of            *
  * CRITICAL IO, INC. Any reproduction of this program without the       *
  * express written consent of CRITICAL IO, INC is a violation of        *
  * the copyright laws and  may subject you to civil liability and       *
  * criminal prosecution.                                                *
  *                                                                      *
  ************************************************************************
******************************************************************************************** */

#ifndef FCAPI_H
#define FCAPI_H

/***** DO NOT EDIT THIS FILE *****/

#include "fctailor.h"                           /* get host specific customizations                                 */

#define FAST_POST_ENABLE_FLAG       (1<<0)      /* Initialization Option field flags                                */
#define IMPLICIT_LIP_ENABLE_FLAG    (1<<1)      /* 2200 only                                                        */
#define IMPLICIT_LOGIN_ENABLE_FLAG  (1<<2)      /* 2200 only                                                        */
#define POINT_TO_POINT_ENABLE_FLAG  (1<<3)
#define CLASS2_ENABLE_FLAG          (1<<4)
#define ACK0_ENABLE_FLAG            (1<<5)
#define AUTO_2_GIG                  (1<<6)
#define FIXED_2_GIG                 (1<<7)
#define FC_OPT_RESERVED1                    (1<<8)
#define FIFTY_OHM_TERMINATION_ENABLE_FLAG   (1<<9)
#define PORT_DB_CHG_NOTIF_ENABLE_FLAG       (1<<10)
#define ARBITRATED_LOOP_PREFERRED_ELSE_P2P  (1<<11)
#define DISABLE_AUTO_LOGIN_ON_LIP			(1<<12)
#define INIT_FW_WO_DMA_FLAG                 (1<<31)    	/* Not used in COTS - set DMA_DOWNLOAD_FW in fctailor.h						*/

#define SUBADDR_RD_EN_FLAG                  (1<<6)
#define SUBADDR_WR_EN_FLAG                  (1<<7)

#define SCSI_COMMAND_LENGTH         16          /* size limit (in bytes) for user supplied scsi commands            */
#define SCSI_COMMAND_32_LENGTH       4          /* size limit (in longwords) for user supplied scsi commands        */

#define REQ_RESP_QUEUE_ENTRY_SIZE   64          /* this and the following sizes are in bytes                        */

#define REQUEST_RESPONSE_QUEUE_SIZE (MaxConcurrentCommands*REQ_RESP_QUEUE_ENTRY_SIZE) 
                                                /* see FCTAILOR.c for MaxConcurrentCommands                         */
#ifdef IP_SUPPORT
#define IP_RCV_QUEUE_ENTRY_SIZE     12          /* 3 32 bit entries per container                                   */
#define IP_RCV_BUF_QUEUE_SIZE       (NumIPRcvBufQEntries*IP_RCV_QUEUE_ENTRY_SIZE)
#define MAX_IP_FP_HANDLES           14          /* max number of handles in fastpost completion                     */
#else
#define IP_RCV_BUF_QUEUE_SIZE       0           /* not used */
#endif
#define MAILBOX_COMMAND_BUFFER_QUEUE_SIZE 128        
#define MAILBOX_COMMAND_BUFFER_BASE_SIZE  8192
#define MAILBOX_COMMAND_BUFFER_SIZE (MAILBOX_COMMAND_BUFFER_BASE_SIZE+(MailboxCommandQueueSize*MAILBOX_COMMAND_BUFFER_QUEUE_SIZE)) /* command and response buffer for mailbox commands */

/* set buffer size for FC-2x00 command and response queues and IP rcv buf queue */
#define FCRM_WORKING_BUFFER_SIZE  ((2*REQUEST_RESPONSE_QUEUE_SIZE) + MAILBOX_COMMAND_BUFFER_SIZE + IP_RCV_BUF_QUEUE_SIZE)

#define MAX_TRANSFER_LENGTH     0xFFFFFFFFL     /* 32 bit length field                              */
#define FC_IP_MAX_TRANSFER      (0x10000 - 256) /* max IP transfer length                           */

#define PORT_ID_MIN         0                   /* min port ID (126 reserved for FL-PORT)           */
#define PORT_ID_MAX         125                 /* max port ID                                      */

#define PORT_MAP_SIZE       128                 /* number of entries in the active port map returned in Fibre_Status */

#define FC2100_VENDOR_ID   0x1077               /* PCI bus vendor ID.  Use this to find the card    */
#define FC2100_DEVICE_ID   0x2100               /* PCI bus Device ID.  Use this to find the card    */
#define FC2200_DEVICE_ID   0x2200               /* PCI bus Device ID.  Use this to find the card    */
#define FC2300_DEVICE_ID   0x2300               /* PCI bus Device ID.  Use this to find the card    */
#define FC2312_DEVICE_ID   0x2312               /* PCI bus Device ID.  Use this to find the card    */
#define FC2322_DEVICE_ID   0x2322               /* PCI bus Device ID.  Use this to find the card    */
#define FC2422_DEVICE_ID   0x2422
#define FC2432_DEVICE_ID   0x2432

#define FC_TRUE     1                           /* boolean values                                   */
#define FC_FALSE    0

#define FC_NULL     0                           /* FCRM NULL value                                  */

#define WATCHDOG_USEC_PER_TICK  116             /* usec per watchdog timer tick                     */
#define RESET_WATCHDOG          0x80            /* Bit 7 in IP control resets watchdog              */

#define FCP_RESPONSE_INFO_SIZE     8               /* status type response info length in bytes     */
#define FCP_RESPONSE_INFO_32_SIZE  2               /* status type response info length in longwords */
#define SCSI_SENSE_DATA_SIZE      32               /* status type sense data length in bytes        */
#define SCSI_TARGET_SENSE_DATA_SIZE 18             /* Length of sense data for target response      */
#define SCSI_SENSE_DATA_32_SIZE    8               /* status type sense data length in longwords    */

#define DEF_FRAME_SIZE          2048            /*  Default Frame size                              */
#define MAX_FRAME_SIZE          2112
#define AMCD_MAX_FRAME_SIZE		2112
#define MID_FRAME_SIZE          1024
#define MIN_FRAME_SIZE           512

#define DEF_TIMEOUT             10              /* a timeout of 10 seconds                          */

#define AUTO_HUB                0               /* OmniPort configuration setting - HUB mode        */
#define AUTO_REDUNDANT_CHANNEL  1               /* Redundant simplex link                           */
#define AUTO_REDUNDANT_LOOP     2               /* Redundant Loop link                              */
#define MANUAL_OVERRIDE         3               /* Cannot be used in call to Fibre_Initialization   */
#define PORT_STATUS_ONLY        4
#define MAX_OMNIPORT_CONFIG PORT_STATUS_ONLY    /* End Marker                                       */

#define LOOPBACK_TEST_LENGTH    2048            /* number of bytes sent during loopback test        */

#define HIGH_RESOLUTION_TIMER   0x8000          /* high bit enables high resolution timer (1msec lsb)*/
                                                /* user specifies in 1 msec but actual implementation*/
#define HIGH_RESOLUTION_TIMER_LSB    5          /* is 5 msec/tick                                    */

#define MaxSubaddresses			256				/* maximum number of enhanced RDMA subaddresses      */
typedef enum
{
    OmniVoid,                                   /* use this for all AUTO and Port Status configs    */
    AllPortLoopback,                            /* use these for all manual override congigurations */    
    BypassQlogic,             
    BypassPort1,              
    BypassPort2,              
    BypassPort1and2,          
    BypassPort1andQlogic,          
    BypassPort2andQlogic,          
    AllPortsActive,           
    RedundantChPort1,         
    RedundantChPort2,         
    RedundantLpPort1_2,       
    RedundantLpPort1,         
    RedundantLpPort2_1,       
    RedundantLpPort2,         
    RedundantLpNoQlogicPort1, 
    RedundantLpNoQlogicPort2
} OmniPortManualModes;


#define FC_BIT0     1
#define FC_BIT1     (1 << 1)
#define FC_BIT2     (1 << 2)
#define FC_BIT3     (1 << 3)
#define FC_BIT4     (1 << 4)
#define FC_BIT5     (1 << 5)
#define FC_BIT6     (1 << 6)
#define FC_BIT7     (1 << 7)
#define FC_BIT8     (1 << 8)
#define FC_BIT9     (1 << 9)
#define FC_BIT10    (1 << 10)
#define FC_BIT11    (1 << 11)
#define FC_BIT12    (1 << 12)
#define FC_BIT13    (1 << 13)
#define FC_BIT14    (1 << 14)
#define FC_BIT15    (1 << 15)
#define FC_BIT16    (1L << 16)
#define FC_BIT17    (1L << 17)
#define FC_BIT18    (1L << 18)
#define FC_BIT19    (1L << 19)
#define FC_BIT20    (1L << 20)
#define FC_BIT21    (1L << 21)
#define FC_BIT22    (1L << 22)
#define FC_BIT23    (1L << 23)
#define FC_BIT24    (1L << 24)
#define FC_BIT25    (1L << 25)
#define FC_BIT26    (1L << 26)
#define FC_BIT27    (1L << 27)
#define FC_BIT28    (1L << 28)
#define FC_BIT29    (1L << 29)
#define FC_BIT30    (1L << 30)
#define FC_BIT31    (1L << 31)

/* As a service to our customers implementing scsi device applications, Delphi includes applicable defs here */
/* These are not a complete list */

/* SCSI Commands (CDB) */

#define SCSI_TUR_CMD        0x00    /* test unit ready                      */
#define SCSI_REQ_SENSE_CMD  0x03
#define SCSI_FORMAT_CMD     0x04
#define SCSI_RECEIVE_CMD    0x08    /* Processor Model receive command      */
#define SCSI_READ_CMD       0x08
#define SCSI_SEND_CMD       0x0A    /* Processor Model send command         */
#define SCSI_WRITE_CMD      0x0A
#define SCSI_SEEK_CMD       0x0B
#define SCSI_INQUIRY_CMD    0x12
#define SCSI_MODE_SELECT    0x15
#define SCSI_MODE_SENSE     0x1A
#define SCSI_START_STOP     0x1B
#define SCSI_RECEIVE_DIAG   0x1C
#define SCSI_SEND_DIAG_CMD  0x1D
#define SCSI_LOCK_UNLOCK    0x1E
#define SCSI_READ_CAPACITY  0x25
#define SCSI_READ_EXTENDED  0x28
#define SCSI_WRITE_EXTENDED 0x2A
#define SCSI_SEEK_EXTENDED  0x2B
#define SCSI_WRITE_VERIFY   0x2E
#define SCSI_VERIFY         0x2F
#define SCSI_PREFECTCH      0x34



/* Sense Key    */
#define SK_NO_SENSE             0x00
#define SK_RECOVERED_ERROR      0x01
#define SK_NOT_READY            0x02
#define SK_MEDIUM_ERROR         0x03
#define SK_HARDWARE_ERROR       0x04
#define SK_ILLEGAL_REQUEST      0x05
#define SK_UNIT_ATTENTION       0x06
#define SK_DATA_PROTECT         0x07
#define SK_FIRMWARE_ERROR       0x09
#define SK_ABORTED_COMMAND      0x0B
#define SK_EQUAL                0x0C
#define SK_VOL_OVERFLOW         0x0D
#define SK_MISCOMPARE           0x0E

/* Additional Sense Code    */
#define ASC_NO_SENSE            0x00
#define ASC_NO_INDEX            0x01
#define ASC_NO_SEEK             0x02
#define ASC_DEV_WRITE_FAULT     0x03
#define ASC_LUN_NOT_READY       0x04
#define ASC_COM_ERROR           0x08
#define ASC_ERR_LOG_OVERFLOW    0x0A
#define ASC_WRITE_ERROR         0x0C
#define ASC_ID_ERROR            0x10
#define ASC_READ_ERROR          0x11
#define RECOVERED_DATA_12       0x12
#define ASC_RECORD_NOT_FOUND    0x14
#define ASC_MECHANICAL_ERROR    0x15
#define ASC_SYNC_ERROR          0x16
#define ASC_RECOVERED_DATA_17   0x17
#define ASC_RECOVERED_DATA_18   0x18
#define ASC_DEFECT_LIST_ERROR   0x19
#define ASC_PARAMETER_LIST_ERROR 0x1A
#define ASC_NO_DEFECT_LIST      0x1C
#define ASC_MISCOMPARE          0x1D
#define ASC_INVALID_COMMAND     0x20
#define ASC_LBA_RANGE           0x21
#define ASC_INVALID_CDB_FIELD   0x24
#define ASC_UNSUPPORTED_LUN     0x25
#define ASC_INVALID_PARAMETER   0x26
#define ASC_WRITE_PROTECTED     0x27
#define ASC_POWER_ON_RESET      0x29
#define ASC_COMMAND_SEQ_ERROR   0x2C
#define ASC_FORMAT_ERROR        0x31
#define ASC_SELFTEST_FAIL       0x42


/* SCSI Status field        */
#define SCSI_STATUS_GOOD                 0x00
#define SCSI_STATUS_ERROR                0x02
#define SCSI_STATUS_CHECK_CONDITION      SCSI_STATUS_ERROR
#define SCSI_STATUS_BUSY                 0x08
#define SCSI_STATUS_INTERMEDIATE         0x10
#define SCSI_STATUS_RESERVATION_CONFLICT 0x18
#define SCSI_STATUS_QUEUE_FULL           0x28
#define SCSI_STATUS_ACA                  0x30

typedef enum
{
    SPEED_1GIG,
    SPEED_2GIG
}FC_CONNECTION_SPEED_TYPE;

typedef enum
{
    FC_SEND,
    FC_SEND_THROTTLED,          /* for use by embedded hardware designs using TX strobe                 */
    FC_SEND_PREFERENCE,         /* send message with hi priority, to put at head of Q */
    FC_RECEIVE = 256
}FC_DIRECTION_TYPE;


typedef enum                    /* transmit/receive protocol type                                       */
{
    FC_INITIATOR, FC_SCSI_INITIATOR = FC_INITIATOR, 
    FC_RDMA_INITIATOR, 
    FC_RDMA_INITIATOR_NO_TARGET_NOTIFICATION,
	FC_RDMA_INITIATOR_MULTICAST,
	FC_RDMA_INITIATOR_MULTICAST_NO_TARGET_NOTIFICATION,
	FC_RDMA_INITIATOR_SG_MULTICAST,
	FC_RDMA_INITIATOR_SG_MULTICAST_NO_TARGET_NOTIFICATION,
    FC_IP_INITIATOR,
    FC_TARGET = 256, FC_SCSI_TARGET = FC_TARGET, FC_IP_TARGET, FC_RDMA_TARGET,  FC_IP_TARGET_BROADCAST
}ProtocolType;

typedef enum                    /* status returned to notification method                               */
{
    FTS_SUCCESS,               /* 0 */
    FTS_ERROR,
    FTS_ABORTED,
    FTS_INVALID_PORT,
    FTS_TIMEOUT,
    FTS_FCRM_INTERNAL_ERROR,    /* 5 */
    FTS_TARGET_BUSY,            /* also returned from default target handler if wants busy response */
    FTS_UNDERRUN,
    FTS_OVERRUN,
    FTS_CHECK_CONDITION,        /* also returnd from target handler if wants check condition response*/
    FTS_TARGET_QUEUE_FULL,      /* 10 */
    FTS_PCI_ERROR,
	FTS_WR_PROT_ERR,
	FTS_RD_PROT_ERR,
	FTS_BOUNDARY_ERR,
	/* Added for AMC&D*/
#ifdef ENABLE_AMCD
    FTS_E_D_TOV,				/* 15 */
	FTS_ACK_TOV,
	FTS_BB_CREDIT_E_D_TOV,
	FTS_SEQ_CNT,
	FTS_RJT_RCVD,
	FTS_BSY_RCVD,				/* 20 */
	FTS_ABTS_RCVD,
	FTS_LOSS_SYNC,
	FTS_AL_TIME,
	FTS_LP_TOV,
	FTS_LP_BB_CREDIT_TOV,		/* 25 */
	FTS_CSU_RCVD,
	FTS_CSR_RCVD,
#endif	
	/* End AMC&D add*/
    FTS_TARGET_RESET,
    FTS_INVALID_REQUEST,
    FTS_BUS_RESET,
    FTS_INVALID_TARGET_TRANSFER, /* 15 */
    FTS_DATA_PCI_ERROR,
    FTS_LUN_RESET,
    FTS_INITIATOR_UNDERRUN,
    /* The following pend status must be at end of enum list */
    FTS_SEGMENTED_TARGET_TRANSFER,
	FTS_PEND_SEGMENTED_TARGET_TRANSFER,
    FTS_PEND_TARGET_TRANSFER,    /* returned from default target handler if requesting pended xfer  */
    FTS_COMPLETE_TRANSEFR_DEFERRED_STATUS,/* 25 */ /* status sent after return from completion notification handler         */
    FTS_COMPLETE_PENDED_TRANSFER,/* completes the target transfer via Fibre_Transfer_Buffer, Status sent*/ 
    FTS_CHECK_PENDED_TRANSFER,   /* forces check condition response to pended target transfer*/
    FTS_BUSY_PENDED_TRANSFER,    /* forces busy response via Fibre_Transfer_Buffer                  */
    FTS_SPECIAL_PENDED_TRANSFER = 128,
    FTS_SPECIAL_STATUS = 128
}FC_TRANSFER_STATUS_TYPE;

typedef enum                    /* Status returned to Status Notification Handler (New in 3.2)     */
{
    FCS_LIP_OCCURRED,					 /* 0 */
    FCS_LOOP_UP,						 /* 1 */
    FCS_LOOP_DOWN,						 /* 2 */
    FCS_WATCHDOG_TIMEOUT,				 /* 3 */
    FCS_SYSTEM_ERROR,					 /* 4 */
    FCS_CONNECTED_POINT_TO_POINT,		 /* 5 */
    FCS_FABRIC_CHANGE,					 /* 6 */
    FCS_PORT_ID,						 /* 7 */
    FCS_OUT_OF_IP_RCV_BUFFERS,			 /* 8 */
#ifdef ENABLE_AMCD						 
	FCS_LIP_ERROR_OCCURRED,				 /* 9 */
	FCS_R_T_TOV,						 /* 10 */
	FCS_PLOGI_OCCURRED,					 /* 11 */
	FCS_PRLI_OCCURRED,					 /* 12 */
	FCS_PRLI_ACC_OCCURRED,				 /* 13 */
	FCS_LOGIN_CMPLT,					 /* 14 */
	FCS_CSU_OCCURRED,					 /* 15 */
	FCS_XFER_ERROR,						 /* 16 */
	FCS_PDISC_OCCURRED,					 /* 17 */
	FCS_PDISC_ACC_OCCURRED,				 /* 18 */
	FCS_READY,							 /* 19 */
	FCS_BP_ACTIVE,						 /* 20 */
	FCS_LOS,							 /* 21 */
	FCS_DBG_DMP_RCVD,					 /* 22 */
	FCS_DBG_TRC_STRT,					 /* 23 */
	FCS_DBG_TRC_STP,					 /* 24 */
	FCS_AL_TIME,						 /* 25 */
	FCS_LP_TOV,							 /* 26 */
#endif
	FCS_PORT_DB_CHANGE_OCCURRED,		 /* 22 */
	FCS_IMMED_NOTIFY_IOCB_RCVD,
    FCS_UNHANDLED_EVENT					 /* 27 */
}FC_STATUS_TYPE;

typedef enum
{
    ALIAS_NON_SPECIFIC_ERROR, ALIAS_LOOPID_USED, ALIAS_ALL_LOOPIDS_USED, ALIAS_COMMAND_PARAM_ERROR,
    ALIAS_RSVD=8, ALIAS_NO_LINK, ALIAS_BUFFER_ALLOCATION_ERROR, ALIAS_RESOURCE_ALLOCATION_ERROR, ALIAS_TIMEOUT,
    ALIAS_NO_SWITCH, ALIAS_NO_TGT_SPRT, ALIAS_FW_NOT_READY, ALIAS_INIT_MODE_DSBLD, ALIAS_PORT_NOT_LOGGED_IN, 
    ALIAS_NO_PORT_RESOURCES, ALIAS_DISC_DSBLD, ALIAS_HARD_ID_VALID, ALIAS_NO_XCHG_FND, ALIAS_RCVD_LS_RJT,
    ALIAS_GETLIST_ACTIVE, ALIAS_SCTP_ACTIVE, ALIAS_BLD_XCHG_FAIL, ALIAS_BP_INIT_FAIL, ALIAS_SCTP_DEINIT,
    ALIAS_LINK_BCKUP_FAIL, ALIAS_CMD_FAIL, ALIAS_TOPO_ERR, ALIAS_RESET, ALIAS_ERR=32
}FC_ALIAS_STATUS_TYPE; 

typedef enum                    /* Connection type set in FIBRE_STATUS_TYPE                         */
{
    FCCT_NOT_VALID,
    FCCT_PRIVATE_LOOP,           /* arbitrated loop, with no switch                                  */
    FCCT_PUBLIC_LOOP,            /* arbitrated loop, with a switch                                   */
    FCCT_NPORT_TO_NPORT_P2P,     /* point to point between two NPorts                                */
    FCCT_NPORT_TO_FPORT_P2P      /* point to point between a NPort and a Switch                      */
}FC_CONNECTION_TYPE;

typedef enum
{
	FC_FARP_REQUESTOR,
	FC_FARP_RESPONDER
}FC_FARP_DIRECTION_TYPE;

typedef enum
{
	FC_FARP_REQ_TX,
	FC_FARP_REQ_MATCH_RCVD, 
	FC_FARP_REPLY_TX, 
	FC_FARP_REPLY_RX_RCVD
}FC_FARP_EVENT_TYPE;
typedef enum
{
	NO_MATCH,
	MATCH_PORT,
	MATCH_NODE,
	MATCH_BOTH
}FC_MATCH_CODE_TYPE;

typedef enum
{
	NO_ACTION,
	SND_LOGIN,
	SND_REPLY,
	LOGIN_AND_REPLY
}FC_ACTION_CODE_TYPE;

typedef enum
{
	FC_SUCCESS,
	FC_NO_RSRC,
	FC_INVALID_MATCH_CODE,
	FC_INVALID_PORT, 
	FC_REJ_RCVD,
	FC_FARP_ERROR
}FC_FARP_STATUS_TYPE;

typedef struct                      /* 128 bit IP Address */
{
    u8 Bytes[16];
} IPAddressType;

typedef struct                      /* World Wide Name data -- 0 element is MSB of 8 byte word      */
{
    u8 Bytes[8];
} WorldWideNameType;

typedef struct                      /* returns SCSI info to initiator app upon transfer complete    */
{
    u16 SCSIStatus;                 /* lower 8 bits = SCSI status from byte 3 of FCP_RSP_IU         */
    u16 Reserved1;
    u16 Reserved2;
    u16 Reserved3;
    u16 ResponseInfoLength;         /* non zero = to length when valid FCP_RSP IU received          */
    u16 SenseDataLength;            /* non zero = to length when valid sense data received          */
    u32 ResidualLength;             /* number of bytes not transferred, if non-zero                 */
    u8  FCPResponseInfo[FCP_RESPONSE_INFO_SIZE];
    u8  SCSISenseData[SCSI_SENSE_DATA_SIZE];
} SCSIStatusInfoType;


typedef struct TransferInfo         /* Used by application and API to set/provide transfer params       */
{
    u8 HostID;                      /* Host adapter ID                                                  */
    ProtocolType TransferProtocol;  /* Initiator or Target protocol                                     */
    FC_DIRECTION_TYPE Direction;    /* send or receive                                                  */
    u16 Subaddress;                 /* data transfer subaddress                                         */
    u16 Port;
    FC_TRANSFER_STATUS_TYPE Status; /* receive or send status                                           */
    u32 BufferAddress;              /* physical buffer address or physical address of descriptor list   */
    u32 BufferSize;                 /* number of bytes transferred to/from the buffer                   */
    u32 RemainingTransferSize;		/* number of bytes remaining in segmented transfer - app read only!!*/
    u32 RDMAOffset;                 /* Specifies where in the targets RDMA buffer to write/read the data */
    u32 PendedTargetHandle;         /* Identifier provided by API to track pended target transfers      */
    u16 DescriptorCount;            /* Number of descriptors in descriptor list, if 0 then              */
                                    /* buffer address = physical PCI address of data otherwise it is the*/
                                    /* Physical PCI address of the start of the descriptor list         */
    u16 Timeout;                    /* Timeout for this transfer - in seconds. If 0 then default is used*/                   
    u32 *DescriptorPtr;             /* Location of descriptor table in processor memory                 */ 
    u32 TransferID;                 /* application specified transfer ID                                */
    u8  CDB[SCSI_COMMAND_LENGTH];   /* optional SCSI command block or 16 bytes of user data             */
    u8  Priority;					/* Priority and Preference value to be sent in FCP_CMND, Data		*/
    SCSIStatusInfoType *SCSIError;  /* pointer to SCSI transfer status structure - FC_NULL if no errors */
    void   (*NotificationMethod)(struct TransferInfo *); /* callback function when transfer complete    */
}TransferInfoType;

typedef struct FARPInfo
{
	u8 HostID;
	u32 FARPId;
	FC_FARP_DIRECTION_TYPE FARPDirection;
	FC_FARP_EVENT_TYPE FARPEvent;
	FC_MATCH_CODE_TYPE MatchCode;
	FC_ACTION_CODE_TYPE ActionCode;
	WorldWideNameType PortName;
	WorldWideNameType NodeName;
	u32 ReqPortID;
	IPAddressType IPAddress;
	FC_FARP_STATUS_TYPE Status;
	void (*NotificationMethod)(struct FARPInfo *);
}FARPInfoType;

typedef struct                    
{                                   /* used to send IP receive buffer containers to the adapter         */
#ifdef STRUCT_CASE1
    u32 ReceivePtrPALo;             /* low 32 bits of the physical address of the buffer                */
    u32 ReceivePtrPAHi;             /* upper 32 bits of the physical address of the buffer              */
    u32 BufferHandle:16;            /* 16 bit unique identifier for the buffer                          */
    u32 Reserved:16;
#else
    u32 ReceivePtrPALo;
    u32 ReceivePtrPAHi;
    u32 Reserved:16;
    u32 BufferHandle:16;
#endif
}UserIPBufContainerType;

typedef struct
{
	WorldWideNameType  NodeName;
	WorldWideNameType  PortName;
#ifdef STRUCT_CASE1
    u32 LoopId:8;
    u32 Rsvd0:8;
    u32 Options:8;
    u32 Control:8;
    u32 LoginMasterState:8;
    u32 LoginSlaveState:8;
    u32 HardId:8;
    u32 Rsvd1:8;
#else
    u32 Control:8;
    u32 Options:8;
    u32 Rsvd0:8;
    u32 LoopId:8;
    u32 Rsvd1:8;
    u32 HardId:8;
    u32 LoginSlaveState:8;
    u32 LoginMasterState:8;
#endif
    u32 PortId;
#ifdef STRUCT_CASE1
    u32 PRLI0:16;
    u32 PRLI1:16;
#else
    u32 PRLI1:16;
    u32 PRLI0:16;
#endif
} NameIdListType;



typedef struct
{
    Boolean   Valid;                /* true if status is valid - otherwise Host ID is invalid           */
    Boolean   LoopUp;               /* True if the loop is up                                           */
    u8        LoopTransitionCount;  /* count of number of times loop has gone down since last status    */
    u8        LIPCount;             /* count of the number of time a LIP has occurred since last status */
    u16       DroppedTransferCount; /* the number of unhandled transfer request since last status       */
    u16       FreeFCRMQueueEntries; /* the number of free transfer entries on the FCRM queue            */
    FC_CONNECTION_TYPE        ConnectionType;       /* ConnectionType                                                   */
    FC_CONNECTION_SPEED_TYPE ConnectionSpeed;      /* Actual Link data rate (1 or 2 gig)                */
    Boolean   IDValid;              /* True if loop ID and Port ID values are updated                   */
    u8        LoopID;               /* the actual loop ID that the NIC is using                         */
    u32       PortID;               /* the acutal 24 bit port ID that the NIC is using.  AL_PA if Loop  */
    Boolean   PortMapValid;         /* true if port map is current                                      */
    u8        PortMap[PORT_MAP_SIZE];/* Maps active ports on the loop                                   */
	Boolean	  SyncValid;			/* true if LOS flag not set											*/
	u8		  NumActivePorts;		/* number of ports in loop or on map - will decrement if logo sent  */
}FIBRE_STATUS_TYPE;


/* the data that is returned from the API's Fibre_Map_Fabric and Fibre_Fabric_Get_Next_PortID           */
/* consists of a 16 byte header followed by a list of entries.                                          */
/* Use the control byte to determine if you are at the last entry in the list                           */

typedef struct                      /* define Fabric controller SNS map fabric response                 */
{
    u8 Header[16];                    /* 16 byte header                                                 */                
                                      /* 16 bit word at offset 8 is completion status                   */
                                      /* 8002h = success, 8001h = fail (Big Endian format)              */
}SNSResponseHeaderType;

typedef struct
{
    u8 ControlByte;                     /* 0 = entry valid, 0x80 = last entry                              */
    u8 PortID[3];                       /* 24 bit portID in Big Endian format                              */
    u8 Reserved[4];
    u8 NodeName[8];                     /* Big endian format and upper nibble (type) is always 0           */
}SNSResponseEntryType;

typedef struct
{
    u8 ControlByte;                     /* 0 = entry valid, 0x80 = last entry                              */
    u8 PortID[3];                       /* 24 bit portID in Big Endian format                              */
}SNSGetPortIDsType;

typedef struct
{
    u8 PortType;                                                    
    u8 PortID[3];                        /* 24 bit portID in Big Endian format                          */                
    u8 NodeName[8];                      /* Big endian format and upper nibble (type) is always 0       */          
    u8 Reserved[608-28];                 /* other details not of specific interest.                     */
}SNSGetNextResponseType;

typedef enum                        /* Initialization return type                                       */
{
    FI_SUCCESS,
    FI_DEVICE_NOT_FOUND,
    FI_DEVICE_NOT_INITIALIZED,
    FI_DEVICE_ALREADY_INITIALIZED,
    FI_KEY_FAIL,
    FI_INVALID_HOST_ID,
    FI_TOO_MANY_ADAPTERS,
    FI_CHECKSUM_FAIL,
    FI_INVALID_FRAME_SIZE,
    FI_INVALID_NUM_SUBADDRESSES,
    FI_INVALID_OMNIPORT_CONFIG,
    FI_DMA_ERROR
}FIBRE_INIT_ERR;

typedef enum                        /* Register, Send, and Receive return type                         */
{
    FT_SUCCESS,
    FT_DEVICE_NOT_INITIALIZED,
    FT_INVALID_HOST_ID,
    FT_INVALID_SUBADDRESS,
    FT_INVALID_PORT,
    FT_INVALID_BUFFER_SIZE,
    FT_INVALID_BUFFER,
    FT_INVALID_PROTOCOL,
    FT_INVALID_DIRECTION,
    FT_INTERNAL_ERROR,
    FT_OUTSTANDING_REQUEST,
    FT_DESCRIPTOR_MISMATCH,
    FT_UNKNOWN_RECORD,
	FT_LOS_STATE,
    FT_PREQUEUED_TARGET_DISABLED,
	FT_ADAPTER_QUEUE_FULL
}FIBRE_TRANSFER_ERR;

typedef u32 FIBRE_TEST_ERR;     /* Fiber_Self_Test return type (bit map)                                */
#define FB_SUCCESS                      0
#define FB_DEVICE_NOT_RESPONDING        FC_BIT0
#define FB_DEVICE_NOT_FOUND             FC_BIT1
#define FB_TEST_REQUEST_NOT_PERMITTED   FC_BIT2
#define FB_RAM_FAIL                     FC_BIT3
#define FB_MAILBOX_FAIL                 FC_BIT4
#define FB_DEVICE_NOT_CLOSED            FC_BIT5

typedef u8 PortDBUpdateOptions;
extern const u8 MaxConcurrentCommands;      /* see fctailor.c         */
#define WITH_FABRIC_PORTS               0x0E	 
#define LOOP_ONLY                       0x0C

typedef enum
{
	FD_ISP_2100,	
	FD_ISP_2200,	
	FD_ISP_2300,	
	FD_ISP_2310,	
	FD_ISP_2312,	
    FD_ISP_2322,
    FD_ISP_2422,
    FD_ISP_2432 
}FIBRE_DEVICE_TYPE;


typedef enum                    /* On Board A/D and Temp converter converter channels (4022 only)*/
{                                                                                      
    FC_A2D_CURRENT,              /* selects current measurement                       {"Supply Current (ma)     "},     */
    FC_A2D_SYS_V3_3,             /* 3.3 Volt supply at PMC connector                  {"System 3.3v Supply (mv) "},     */
    FC_A2D_INPUT_VOLTAGE,        /* 3.3 or 5 volts going to on board power converters {"Input Voltage (mv)      "},     */
    FC_A2D_CARD_V3_3,            /* On Card 3.3 volt supply                           {"Board's 3.3v Supply (mv)"},     */
    FC_NOT_USED,                 /* not used                                          {"------------------------"},     */
    FC_A2D_CARD_V1_8,            /* On Card 1.8 volt supply                           {"Board's 1.8v Supply (mv)"},     */
    FC_A2D_SYS_V5_0,             /* 5.0 Volt supply at PMC connector                  {"System 5v Supply (mv)   "},     */
    FC_A2D_PCI_VIO,              /* PCI VIO voltage                                   {"PCI Bus VIO (mv)        "},     */
    FC_A2D_TEMP                  /* selects temperature reading                       {"Temperature (degrees C) "}};    */
}A2DChannelType;
                                                                                       

/* Public configuration vars      */
extern const Boolean InterruptMode;         /* must be set fctailor.c */
extern const u8 MaxConcurrentCommands;      /* see fctailor.c         */
extern const u8 MailboxCommandQueueSize;    /* see fctailor.c         */

extern const u32 FC2100ResetDelay;          /* see fctailor.c         */
extern const u16 NumIPRcvBufQEntries;       /* see fctailor.c         */

/* Public API Function Prototypes */

FIBRE_INIT_ERR Fibre_Initialization(BaseAddressType BASE_ADDRESS,
                                    u8 HOST_ID,
                                    u8 *WORKING_BUFFER,
                                    u16 FRAME_SIZE,
                                    u32 Options,
                                    u8 TimeOut,
                                    WorldWideNameType *WorldWideNameIn,
                                    WorldWideNameType *NodeWideNameIn,
									FIBRE_DEVICE_TYPE Device,
                                    void (*StatusHandler)(u8 Adapter, u32 Status, u32 Info));

FIBRE_STATUS_TYPE Fibre_Status(u8 HOST_ID);

FIBRE_TRANSFER_ERR Fibre_Transfer_Buffer(TransferInfoType *TRANSFER_INFO);

FIBRE_TRANSFER_ERR Fibre_Register_Target_Handler(u8 HOST_ID, void (*TARGET_HANDLER)(TransferInfoType *));

FIBRE_TRANSFER_ERR Fibre_Register_FARP_Handler(u8 HostID, void (*FARPHandler)(FARPInfoType *));

FIBRE_TEST_ERR Fibre_Self_Test(BaseAddressType BaseAddress, u16 DeviceID, Boolean SkipRAMTest,
                               u8 *RAMTestBuffer, u32 RAMTestBufferPA, u32 RAMSize, u32* FirstFailAddress);

FIBRE_TRANSFER_ERR Fibre_Service(u8 HOST_ID, Boolean *MyInt);

FIBRE_TRANSFER_ERR Fibre_Abort_Target_Port(u8 HostID, u16 PortID,
                                           u32 ID, void (*CallBackFunction)(u32 Status, u32 ID));

FIBRE_TRANSFER_ERR Fibre_Bus_Reset(u8 HostID,
                                   u32 ID, void (*CallBackFunction)(u32 Status, u32 ID));

FIBRE_TRANSFER_ERR Fibre_Abort_Initiator_Transfer(u8 HostID, FC_DIRECTION_TYPE Direction, u32 TransferID,
                                                  u32 ID, void (*CallBackFunction)(u32 Status, u32 ID));

FIBRE_TRANSFER_ERR Fibre_LUN_Reset(u8 HostID, u16 PortID, u16 LUN,
                                   u32 ID, void (*CallBackFunction)(u32 Status, u32 ID));
                                                  
FIBRE_TRANSFER_ERR Fibre_Close(u8 HOST_ID, Boolean FastClose);

FIBRE_TRANSFER_ERR Fibre_Abort_Target_Transfer(u8 HostID, FC_DIRECTION_TYPE Direction, u32 Transfer_ID);

WorldWideNameType Fibre_Get_World_Wide_Name(BaseAddressType BaseAddress);

FIBRE_TRANSFER_ERR Fibre_Get_WWN_For_LoopID(u8 HostID, u16 LoopID, WorldWideNameType *WWN,  Boolean GetNodeName,
                                            u32 ID, void (*CallBackFunction)(u32 Status, u32 ID));

FIBRE_TRANSFER_ERR Fibre_Get_Name_Id_List(u8 HostID, u8 Options, NameIdListType *List,
                                            u32 ID, void (*CallBackFunction)(u32 Status, u32 ID, u8 NumPorts));

FIBRE_TRANSFER_ERR Fibre_Force_LIP(u8 HostID, u32 ID, void (*CallBackFunction)(u32 Status, u32 ID));

FIBRE_TRANSFER_ERR Fibre_OmniPort_Control(u8 HostID, u16 Command, OmniPortManualModes Mode,
                                         u32 ID, void (*CallBackFunction)(u32 Status, u32 ID));

FIBRE_TRANSFER_ERR Fibre_Fabric_Alias_DID_To_LoopID(u8 HostID, u32 PortID24, u16 FabricTargetPortLoopIDAlias,
                                                    u32 CommandID, void (*CallBackFunction)( u32 Status, u32 CommandID));
                                                                                     
FIBRE_TRANSFER_ERR Fibre_Fabric_Map(u8 HostID, u32 Protocol, u32 ResponseBufferPA, u32 ResponseBufferLength,
                                    u32 CommandID, void (*CallBackFunction)( u32 Status, u32 CommandID));

FIBRE_TRANSFER_ERR Fibre_Fabric_Get_All_PortIDs(u8 HostID, u32 PortType, u32 ResponseBufferPA, u32 ResponseBufferLength,
                                    u32 CommandID, void (*CallBackFunction)( u32 Status, u32 CommandID));

FIBRE_TRANSFER_ERR Fibre_Fabric_Get_Next_PortID(u8 HostID, u32 LastPortID, u32 ResponseBufferPA, u32 ResponseBufferLength,
                                    u32 CommandID, void (*CallBackFunction)( u32 Status, u32 CommandID));
                                    
FIBRE_TRANSFER_ERR Fibre_Fabric_Register_Protocol(u8 HostID, u32 PortID, u32 Protocol, u32 ResponseBufferPA, u32 ResponseBufferLength,
                                    u32 CommandID, void (*CallBackFunction)( u32 Status, u32 CommandID));
                                    
FIBRE_TRANSFER_ERR Fibre_Register_RDMA(u8 HostID, u32 BufferBasePA, u32 ID,
                                      void (*NotificationHandler)(TransferInfoType *),
                                      void (*CallBackFunction)(u32 Status, u32 ID));
                                                                                         
/* Added for enhanced RDMA */
FIBRE_TRANSFER_ERR Fibre_Register_RDMA_SubAddr(u8 HostID, u32 BufferBasePA, u32 length,
                                      u8 flags, u8 subaddress, u32 ID,
                                      void (*NotificationHandler)(TransferInfoType *),
                                      void (*CallBackFunction)(u32 Status, u32 ID));

FIBRE_TRANSFER_ERR Fibre_Register_RDMA_Multiple(u8 HostID, u8 *TablePtr, u32 TablePA, u32 ID,
                                      void (*NotificationHandler)(TransferInfoType *),
                                      void (*CallBackFunction)(u32 Status, u32 ID));

FIBRE_TRANSFER_ERR Fibre_Get_SubAddr_List(u8 HOST_ID, u32 *ListPtr, u32 ListAddress, u32 CommandID, 
                                        void (*CallBackFunction)(u32 Status, u32 ID));

FIBRE_TRANSFER_ERR Fibre_Get_SubAddr_Single(u8 HOST_ID, u8 SubAddress, u32 CommandID, 
                                        void (*CallBackFunction)(u16 Status, u32 Id, u16 Flgs_LenMSB, u16 LenLSW, u16 AddrLSW, u16 AddrMSW));
/* end enhanced RDMA addition */

FIBRE_TRANSFER_ERR Fibre_Register_Fast_IP_Buffer(u8 HostID, u32 BufferBasePA, u16 NumberOfBlocks, u32 ID,
                                       void (*CallBackFunction)(u32 Status, u32 ID));

FIBRE_TRANSFER_ERR Fibre_Reset_Error_Statistics(u8 HostID, u32 CommandID, 
                                                void (*CallBackFunction)( u32 Status, u32 CommandID));

FIBRE_TRANSFER_ERR Fibre_Diagnostic_Echo_Test(u8 HostID, u16 DataLength, u32 RXBufferBasePA, 
                                       u32 TXBufferBasePA ,u32 ID,
                                       void (*CallBackFunction)(u32 Status, u32 ID));

FIBRE_TRANSFER_ERR Fibre_LoopBack_Test(u8 HostID, u32 RXBufferBasePA, u32 TXBufferBasePA,
                                       u32 IterationCount, Boolean External, u32 Size, u32 ID,
                                       void (*CallBackFunction)(u32 Status, u32 ID));
                                       
FIBRE_TRANSFER_ERR Fibre_Enable_Watchdog(u8 HostID, u16 Timeout, u32 ID, void (*CallBackFunction)(u32 Status, u32 ID));

FIBRE_TRANSFER_ERR Fibre_Enable_IP_Protocol(u8 HostID, u16 MTU, u16 IPHeaderSize,
                                            u16 RxBufferSize, u32 ID, 
                                            void (*CallBackFunction)(u32 Status, u32 ID));
                                           
FIBRE_TRANSFER_ERR Fibre_Get_Link_Data_Rate(u8 HostID, u32 CommandID, 
												void (*CallBackFunction)( u32 Status, u32 CommandID));

#ifdef IP_SUPPORT
FIBRE_TRANSFER_ERR Fibre_Add_IP_Buffers(u8 HostID, UserIPBufContainerType *ContainerPtr, u8 NumBuffers);

FIBRE_TRANSFER_ERR Fibre_Send_FARP_Protocol(FARPInfoType *FARPInfo);
#endif


FIBRE_TRANSFER_ERR Fibre_Define_Implicit_Port(u8 HostID, u8 LoopID, u32 RemotePortID, u16 RemoteFrameSize,
                                              u16 RemoteControlOptions, u32 ID,
                                              void (*CallBackFunction)(u32 Status, u32 ID));
                                              
void Fibre_IntDisable(BaseAddressType BaseAddress);

void Fibre_IntEnable(BaseAddressType BaseAddress);

/* FOR TEST ONLY */
FIBRE_TRANSFER_ERR Fibre_Send_Mailbox_Command(u8 HostID, u16 MB0, u16 MB1, u16 MB2, u16 MB3, u16 MB6, u16 MB7,
                                              void (*CallBackFunction)(u16 MB0, u16 MB1, u16 MB2, u16 MB3, u16 MB6, u16 MB7));
                                              
FIBRE_TRANSFER_ERR Fibre_Driver_Heartbeat(u8 HostID, u16 HBInterval, u32 CommandID, 
											void (*CallBackFunction)( u32 Status, u32 CommandID));

FIBRE_TRANSFER_ERR Fibre_Firmware_Heartbeat(u8 HostID, u16 HBInterval, u32 HBTargetPA,
                                    u32 CommandID, void (*CallBackFunction)( u32 Status, u32 CommandID));



/* These functions are defined in FCTAILOR.C.  The user is responsible for providing the proper functionality based on the target system */

                                       
Boolean Fibre_Lock(u8 HOST_ID);                         /**** User Defined Function in FCTAILOR.C ****/

Boolean Fibre_Release(u8 HOST_ID);                      /**** User Defined Function in FCTAILOR.C ****/

void *Fibre_Malloc(u32 SIZE);                           /**** User Defined Function in FCTAILOR.C ****/

void Fibre_Free(void *PTR, u32 SIZE);                   /**** User Defined Function in FCTAILOR.C ****/

void FCWrite16(BaseAddressType ADDRESS, u16 VALUE);     /**** User Defined Function in FCTAILOR.C ****/

#ifdef ISP24XX
void FCWrite32(BaseAddressType ADDRESS, u32 VALUE);     /**** User Defined Function in FCTAILOR.C ****/
#endif

u16 FCRead16(BaseAddressType ADDRESS);                  /**** User Defined Function in FCTAILOR.C ****/                               

u32 FCRead32(BaseAddressType ADDRESS);                  /**** User Defined Function in FCTAILOR.C ****/                               

void FCDelay(u32 Count);                                /**** User Defined Function in FCTAILOR.C ****/  

void* FC_Physical_To_Processor(u32 PhysicalAddress);    /**** User Defined Function in FCTAILOR.C ****/

u32 FC_Processor_To_Physical(void *ProcessorAddress);   /**** User Defined Function in FCTAILOR.C ****/                


FIBRE_TRANSFER_ERR Fibre_I2C_A_D_Read(u8 HostID, A2DChannelType Channel, u32 CommandID, void (*CallBackFunction)( u32 Status, u32 CommandID));

FIBRE_TRANSFER_ERR Fibre_I2C_TempRead(u8 HostID, u32 CommandID, void (*CallBackFunction)( u32 Status, u32 CommandID));

#endif /* FCAPI_H */

 
